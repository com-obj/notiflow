@startuml
!theme cerulean-outline


skinparam component {
    BackgroundColor<<user defined>> LightGray
    BorderColor<<user defined>> Gray
    FontColor<<user defined>> Black
    ArrowColor<<get>> #FF6655

    FontColor DarkSlateGray
    FontName Courier
    FontSize 15

    FontSize<<PUB/SUB>> 12
}
    
database "PostgreSQL" {
    component nc_failed_payload [
        nc_failed_payload
        --
        (FailedPaylod)
    ]
}

database "Topic/Channels" {

    component errorChannel [
        errorChannel
        --
        (ErrorMessage)
    ]

    note left of errorChannel 
        In case of exception in any step of any flow, 
        the failed message is recieved by this channel 
        with information about which step was the last that failed
        For this to work in any situation, transaction boundires has to 
        be on each step of the flow
    end note  

}

component [noti-flow] as mainFlow {


    package standard-flow {
        [FAILED_STEP]        
    }

    note bottom of FAILED_STEP 
        resurected message is send to the step which produced the error
        to try finishing the processing again
    end note  

    package rest-api {
        [ErrorHandling]<<REST API>>    

        ErrorHandling .> nc_failed_payload: <<get>> (FailedPaylod)   
        ErrorHandling --> FAILED_STEP
    }

    package error-handling-flow {
         [ErrorHandlingFlow]
        
    }


    ErrorHandlingFlow .u.> errorChannel: <<get>>
    ErrorHandlingFlow --> nc_failed_payload: <<put>>
}

interface "URL: rest/errors/{failedPaylodId}/resurrect" as restErrorResurectInt
ErrorHandling -l- restErrorResurectInt: \t\t\t\t

@enduml