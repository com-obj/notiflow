{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notiflow Notiflow is software framework for reliable delivery of email, push notifications and other types of messages. It is written in Java and it uses various Spring modules especially Spring integration. You can find the full list of features To create your first \"Hello world\" project, check the Getting started section To learn more about the architecture and how it is build, check the architecture and design section Goals The main goal of notiflow is to greatly simplify delivery of information messages to the end user of your application. This is achieved by providing solution for many generic problems of message delivery while taking into account the was diversity of use-cases in which application operate and send messages. The problems which notiflow is solving are allow application to emit events and don't worry about who and what should be communicated to the end-users on those events hide complexity of sending messages via different channels like Email, Push, Sms, Mailchimp, .. allow for scalability from tiny to thousand messages per second ensure reliable delivery with delivery error handling provide comprehensive monitoring and debugging of messages processing provide UI for message delivery statistics, metrics and processing details allow for testing message routing, formatting and delivery end-user spam prevention message aggregation To understand in details how notiflow is solving this problems check the full list of features here Architecture and design Main design characteristics of Notiflow are focusing about achieving two main principles Allow for high level of customization Provide solution which can be used as embedded library standalone application on single machine microservice oriented application operating on computer cluster of any size to achieve high level of thruput To achieve this goals notiflow is implemented as set of independent functions where each function is performing exactly one thing (event conversion, email sending, formatting, aggregation, .. ) notiflow provide default composition of these functions which are called flows . Both functions and flows can be added custom functionality is required. It is also possible to customize existing functions or flows using configuration properties or by providing completely custom implementation. You can use Notiflow as embedded into your existing application create custom microservice for notification processing Functions A function in notiflow is a component which performs single distinct operation. It can be a transformation, getting data from another system, persisting processing information or anything else which is important for message delivery. To see full list of implemented functions and for detail description of each individual function, check the API documentation on functions Flows Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow . The data exchange between function in a flow (or between flows) is performed using exchange of data objects which is implemented based on the scalability and deployment requirements either in-memory RabbitMQ Kafka To understand what is the composition of functions into each individual flow , navigate to the Flows chapter The description of data structures and entities exchanged between functions and flows can be found in Entities chapter Web UI Notiflow ships with monitoring and reporting UI written in ReactJS. It aim is to provide reporting and monitoring dashboards graphical interface for configuration of various aspects of notiflow support for message routing and delivery testing Test mode For complete documentation and screenshots of UI navigate to Web UI chapter Let's start To start using Notiflow in your project, navigate to the Getting started section","title":"Fundamentals"},{"location":"#notiflow","text":"Notiflow is software framework for reliable delivery of email, push notifications and other types of messages. It is written in Java and it uses various Spring modules especially Spring integration. You can find the full list of features To create your first \"Hello world\" project, check the Getting started section To learn more about the architecture and how it is build, check the architecture and design section","title":"Notiflow"},{"location":"#goals","text":"The main goal of notiflow is to greatly simplify delivery of information messages to the end user of your application. This is achieved by providing solution for many generic problems of message delivery while taking into account the was diversity of use-cases in which application operate and send messages. The problems which notiflow is solving are allow application to emit events and don't worry about who and what should be communicated to the end-users on those events hide complexity of sending messages via different channels like Email, Push, Sms, Mailchimp, .. allow for scalability from tiny to thousand messages per second ensure reliable delivery with delivery error handling provide comprehensive monitoring and debugging of messages processing provide UI for message delivery statistics, metrics and processing details allow for testing message routing, formatting and delivery end-user spam prevention message aggregation To understand in details how notiflow is solving this problems check the full list of features here","title":"Goals"},{"location":"#architecture-and-design","text":"Main design characteristics of Notiflow are focusing about achieving two main principles Allow for high level of customization Provide solution which can be used as embedded library standalone application on single machine microservice oriented application operating on computer cluster of any size to achieve high level of thruput To achieve this goals notiflow is implemented as set of independent functions where each function is performing exactly one thing (event conversion, email sending, formatting, aggregation, .. ) notiflow provide default composition of these functions which are called flows . Both functions and flows can be added custom functionality is required. It is also possible to customize existing functions or flows using configuration properties or by providing completely custom implementation. You can use Notiflow as embedded into your existing application create custom microservice for notification processing","title":"Architecture and design "},{"location":"#functions","text":"A function in notiflow is a component which performs single distinct operation. It can be a transformation, getting data from another system, persisting processing information or anything else which is important for message delivery. To see full list of implemented functions and for detail description of each individual function, check the API documentation on functions","title":"Functions "},{"location":"#flows","text":"Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow . The data exchange between function in a flow (or between flows) is performed using exchange of data objects which is implemented based on the scalability and deployment requirements either in-memory RabbitMQ Kafka To understand what is the composition of functions into each individual flow , navigate to the Flows chapter The description of data structures and entities exchanged between functions and flows can be found in Entities chapter","title":"Flows "},{"location":"#web-ui","text":"Notiflow ships with monitoring and reporting UI written in ReactJS. It aim is to provide reporting and monitoring dashboards graphical interface for configuration of various aspects of notiflow support for message routing and delivery testing Test mode For complete documentation and screenshots of UI navigate to Web UI chapter","title":"Web UI "},{"location":"#lets-start","text":"To start using Notiflow in your project, navigate to the Getting started section","title":"Let's start "},{"location":"entities/","text":"Entities Input event Notification intent Message Delivery info Processing info Failed payload","title":"Payloads"},{"location":"entities/#entities","text":"","title":"Entities"},{"location":"entities/#input-event","text":"","title":"Input event "},{"location":"entities/#notification-intent","text":"","title":"Notification intent "},{"location":"entities/#message","text":"","title":"Message "},{"location":"entities/#delivery-info","text":"","title":"Delivery info "},{"location":"entities/#processing-info","text":"","title":"Processing info "},{"location":"entities/#failed-payload","text":"","title":"Failed payload "},{"location":"examples/","text":"","title":"Examples"},{"location":"features/","text":"Notiflow features There are many applications that communicate with its users in an asynchronous fashion using various means like emails or mobile push messages. Sending a message seems to be a simple task at first and most application decide for straight forward solution and use Emails to communicate with users. In most cases they simply call SMTP server when condition for notification are met. This approach can quickly result in unexpected and non-trivial development costs as the requirements evolve. Example of such requirements are * Email has to be generated from template * Notification has to have some delivery guaranties and the engine has to be able to handle error cases * What was send? To whom? And when? * Notification has to be send using different channel, not only via Email. This can be Push notification on mobil phone, Slack message, SMS, .. * and there are many more. Notiflow solve a lot of these generic problems. The list of all its features is described in the next chapiters. Different messaging channels Notiflow let you abstract from channel you want to use to inform your users or customers an takes care about implementation details of these channels. Email Android/iOS push message SMS Facebook post Tweet Slack Microsoft Teams message ... To find out more about how to configure the various channels check the configuration options of specific sender Message templates You can define beautiful dynamic message content using Thymeleaf templates across all of the message channels. To find out more about configuration of templates check our Cook book in the templates section. Test mode Test your configuration before going to production. Notiflow let you turn on the Test mode which ensures that all processing happens like in normal production environment except of the send step. Instead, messages get aggregated and can be inspected using Web UI or will be send in single digest Email. To find out more about turning on the test mode check our Cook book in the Test mode section. Message delivery in predefined hours You can configure how and when recipients should receive your message. For example you might want to send SMS in working hours and Email on weekends you can postpone the message delivery if outside of working hours. Message aggregation Instead of sending message each time some application event occurs, configure notiflow to send single aggregated message which consists of all messages which would have been send in the given time period Massage delivery tracking Have a detailed view on status of your notification. For most channels we provided information if the messages is currently being Processing in notiflow Sent to recipient Delivered Read Failed You can further inspect when and how the message or event has been processed using the Web UI Fault tolerance Notiflow provides several level of fault tolerance. You can deploy notiflow on you computer cluster and provide fault tolerance of HW infrastructure by duplicating components which are processing messages. The components ( functions ) communicate using some message broker and the deployment provides not only assurance against HW outages but allows for high throughput if required. If message processing fails because of problems in data of network connectivity to 3rd party components, notiflow will put the message to the area for failed messages and allow user to resurrect the message processing from the failed step once the problem has been resolved Recipient spam prevention Do you have customers that you definitively don't want to send more than N messages in a given time period? Configure spam prevention mechanism in notiflow to either reject messages which would pass the limit or send them as single aggregate message at the end of that period. Message prioritization Notiflow does its best to process messages as fast as possible but there might be a case when you want the message to be delivered before Notiflow processes all prior messages. For this purpose, you can prioritize your messages so that the more important are always processed before the others. Scheduled notification If you need to query some other resources to find out if something important happened, so that you can notify those who are interested, you can schedule when the notification flow should start. Web UI for monitoring and statistics Get deep inside into using our Web UI What event has beed received by the Notiflow What are delivery statistics What messages has been received by specific recipient What messages would have been send if not in Test mode","title":"Features"},{"location":"features/#notiflow-features","text":"There are many applications that communicate with its users in an asynchronous fashion using various means like emails or mobile push messages. Sending a message seems to be a simple task at first and most application decide for straight forward solution and use Emails to communicate with users. In most cases they simply call SMTP server when condition for notification are met. This approach can quickly result in unexpected and non-trivial development costs as the requirements evolve. Example of such requirements are * Email has to be generated from template * Notification has to have some delivery guaranties and the engine has to be able to handle error cases * What was send? To whom? And when? * Notification has to be send using different channel, not only via Email. This can be Push notification on mobil phone, Slack message, SMS, .. * and there are many more. Notiflow solve a lot of these generic problems. The list of all its features is described in the next chapiters.","title":"Notiflow features"},{"location":"features/#different-messaging-channels","text":"Notiflow let you abstract from channel you want to use to inform your users or customers an takes care about implementation details of these channels. Email Android/iOS push message SMS Facebook post Tweet Slack Microsoft Teams message ... To find out more about how to configure the various channels check the configuration options of specific sender","title":"Different messaging channels"},{"location":"features/#message-templates","text":"You can define beautiful dynamic message content using Thymeleaf templates across all of the message channels. To find out more about configuration of templates check our Cook book in the templates section.","title":"Message templates"},{"location":"features/#test-mode","text":"Test your configuration before going to production. Notiflow let you turn on the Test mode which ensures that all processing happens like in normal production environment except of the send step. Instead, messages get aggregated and can be inspected using Web UI or will be send in single digest Email. To find out more about turning on the test mode check our Cook book in the Test mode section.","title":"Test mode"},{"location":"features/#message-delivery-in-predefined-hours","text":"You can configure how and when recipients should receive your message. For example you might want to send SMS in working hours and Email on weekends you can postpone the message delivery if outside of working hours.","title":"Message delivery in predefined hours"},{"location":"features/#message-aggregation","text":"Instead of sending message each time some application event occurs, configure notiflow to send single aggregated message which consists of all messages which would have been send in the given time period","title":"Message aggregation"},{"location":"features/#massage-delivery-tracking","text":"Have a detailed view on status of your notification. For most channels we provided information if the messages is currently being Processing in notiflow Sent to recipient Delivered Read Failed You can further inspect when and how the message or event has been processed using the Web UI","title":"Massage delivery tracking"},{"location":"features/#fault-tolerance","text":"Notiflow provides several level of fault tolerance. You can deploy notiflow on you computer cluster and provide fault tolerance of HW infrastructure by duplicating components which are processing messages. The components ( functions ) communicate using some message broker and the deployment provides not only assurance against HW outages but allows for high throughput if required. If message processing fails because of problems in data of network connectivity to 3rd party components, notiflow will put the message to the area for failed messages and allow user to resurrect the message processing from the failed step once the problem has been resolved","title":"Fault tolerance"},{"location":"features/#recipient-spam-prevention","text":"Do you have customers that you definitively don't want to send more than N messages in a given time period? Configure spam prevention mechanism in notiflow to either reject messages which would pass the limit or send them as single aggregate message at the end of that period.","title":"Recipient spam prevention"},{"location":"features/#message-prioritization","text":"Notiflow does its best to process messages as fast as possible but there might be a case when you want the message to be delivered before Notiflow processes all prior messages. For this purpose, you can prioritize your messages so that the more important are always processed before the others.","title":"Message prioritization"},{"location":"features/#scheduled-notification","text":"If you need to query some other resources to find out if something important happened, so that you can notify those who are interested, you can schedule when the notification flow should start.","title":"Scheduled notification"},{"location":"features/#web-ui-for-monitoring-and-statistics","text":"Get deep inside into using our Web UI What event has beed received by the Notiflow What are delivery statistics What messages has been received by specific recipient What messages would have been send if not in Test mode","title":"Web UI for monitoring and statistics"},{"location":"flows/","text":"Flows Flow is composition of functions (build-in or provided via customisation) that performs some complex logic. Flows can be further composed into final processing flow. The data between functions in a flow (or between flows) are exchanges via spring integration channels which can me in-memory or configured to some message broker like RabitMQ or Kafka Top-level flows (standard-flow) The default configuration of notiflow cosists of 4 procesing stages EventReceiver : Recieve and persist input application Event InputEventExtensionConverting : Event to Intent / Message conversion MessageProcessingFlow : Message persistance, formatting, .. Sending : Sending different types of messages via dedicated channel This is high level and simplified view on defualt notiflow message processing. Next section describe individual flows in detail Notification processing variants The input to standard-flow (and thus start of input processing) can be done by calling one tree dedicated API enpoints Input event call to persistGenericEvent API method or call REST API Post to /events endpoint Notification intent call processIntent API method Specific Message call processMessage API method or call REST API Post to /messages endpoint Which one of these three types is selected by the client depends on the particular use-case. Input event : This is used when you want to use notiflow as reciever of any specifi application event your application can produce. This can be events like \"New order\" in web shop \"Low inventory\" in wharehouse User reuquest for 2-factor authentication ... and any other you might need The intension using this aproach is to ofload as much of the notification processing from the client application as possible. The application focuses on its core business and emits event about what happed. The payload stored in [Input event] can be completely custom and uknown to notiflow Notification intent : TODO Message : Client application already knows everything about the notification it wants to send, especially who is the recipient what is the message type ( Email / SMS / Push /...) what is the message content but still wants to use features like message delivery guaranties , journaling , spam preventions , statistics and others Input event routing flow Input event routing flow is responsible for Recieve an event and retun controll to the caller as soon as possible Recieve an event persist the event return controll to the caller as soon as event persisted in notflow DB Poll for events which should start processing and route them based on the notiflow configuration for input event routing for further processing This step is only active if client what to use event as a starting point for notification processing Input event extension converting flow This flow is a place of common customisation. It main purpose is transleate event to either message or notificationIntent Becuase the payload in event is not know to notiflow, client has to provide custom implementation of such conversion. This is done by implementing InputEvent2MessageConverterExtension interface. For example @Bean public InputEvent2MessageConverterExtension event2Message() { return new InputEvent2MessageConverterExtension () { @Override public Optional<PayloadValidationException> canHandle(GenericEvent payload) { if (payload.getPayloadAsPojo() instanceof TestPayload) { return Optional.empty(); } return Optional.of(new PayloadValidationException(\"No test payload\")); } @Override public List<com.obj.nc.domain.message.Message<?>> convertEvent(GenericEvent event) { EmailMessage email1 = new EmailMessage(); email1.addRecievingEndpoints( EmailEndpoint.builder().email(\"test@objectify.sk\").build() ); email1.getBody().setSubject(\"Subject\"); email1.getBody().setText(\"text\"); List<com.obj.nc.domain.message.Message<?>> msg = Arrays.asList(email1); return msg; } }; } InputEvent2MessageConverterExtension implementation has to be registered as Spring @Bean Intent processing flow TODO Message processing flow The responsiblity of this flow is to perform journaling for all messages which are about to be send. This includes persistance of message and information about recipient of the message. route the message to type dependent sender This flow has API that allows to interact with it. Example: @Autowired private MessageProcessingFlow msgFlow; void exampleSendMessage() { EmailMessage msg = ... // when msgFlow.processMessage(msg); } Email processing Flow The responsiblity of this flow is to if the email is templated , formate it to final email message if email is localised , send email-per-locale or aggregated into one email decorated html emails to track mail opened by recipient send email This flow has API that allows to interact with it. Example: @Autowired private EmailProcessingFlow emailSendingFlow; void exampleSendFormatedEmail() { EmailMessageTemplated<?> email = ... emailSendingFlow.formatAndSend(email); ... } or @Autowired private EmailProcessingFlow emailSendingFlow; void exampleSendEmail() { EmailMessage email = ... EmailMessage emailSent = emailSendingFlow .sendEmail(email) .get(1, TimeUnit.SECONDS); } SMS processing Flow The responsiblity of this flow is to format SMS message content (only templated SMS are supported as of now) send SMS message MailChimp processing Flow The responsiblity of this flow is to send Email message using MailChimp transactional API . Formating of the email is in responsibility of MailChimp Error handling flow In the case of exception in any function participating in a flow , the message that caused the error is recieved by this channel with the information about which step was the last that failed. This flow is reposible for resurection af the failed message and execution of retry For this to work in any situation, transaction boundries for steps in flows have to be carefully defined Delivery Info flows These flows are responsible for persistance of varios journaling information. They listen on predefined topics and document delivery information for given event , intent and message The infomration is later used in notiflow UI for cstatistics and analytics Test mode flow This is an internal flow which is used in test mode . Its responsibility is to Wait for certain time for messages which should have been send if test mode was not active Aggregate them into single digest Email message Send aggreagted email to predefined recipient","title":"Flows"},{"location":"flows/#flows","text":"Flow is composition of functions (build-in or provided via customisation) that performs some complex logic. Flows can be further composed into final processing flow. The data between functions in a flow (or between flows) are exchanges via spring integration channels which can me in-memory or configured to some message broker like RabitMQ or Kafka","title":"Flows"},{"location":"flows/#top-level-flows-standard-flow","text":"The default configuration of notiflow cosists of 4 procesing stages EventReceiver : Recieve and persist input application Event InputEventExtensionConverting : Event to Intent / Message conversion MessageProcessingFlow : Message persistance, formatting, .. Sending : Sending different types of messages via dedicated channel This is high level and simplified view on defualt notiflow message processing. Next section describe individual flows in detail","title":"Top-level flows (standard-flow)"},{"location":"flows/#notification-processing-variants","text":"The input to standard-flow (and thus start of input processing) can be done by calling one tree dedicated API enpoints Input event call to persistGenericEvent API method or call REST API Post to /events endpoint Notification intent call processIntent API method Specific Message call processMessage API method or call REST API Post to /messages endpoint Which one of these three types is selected by the client depends on the particular use-case. Input event : This is used when you want to use notiflow as reciever of any specifi application event your application can produce. This can be events like \"New order\" in web shop \"Low inventory\" in wharehouse User reuquest for 2-factor authentication ... and any other you might need The intension using this aproach is to ofload as much of the notification processing from the client application as possible. The application focuses on its core business and emits event about what happed. The payload stored in [Input event] can be completely custom and uknown to notiflow Notification intent : TODO Message : Client application already knows everything about the notification it wants to send, especially who is the recipient what is the message type ( Email / SMS / Push /...) what is the message content but still wants to use features like message delivery guaranties , journaling , spam preventions , statistics and others","title":"Notification processing variants"},{"location":"flows/#input-event-routing-flow","text":"Input event routing flow is responsible for Recieve an event and retun controll to the caller as soon as possible Recieve an event persist the event return controll to the caller as soon as event persisted in notflow DB Poll for events which should start processing and route them based on the notiflow configuration for input event routing for further processing This step is only active if client what to use event as a starting point for notification processing","title":"Input event routing flow "},{"location":"flows/#input-event-extension-converting-flow","text":"This flow is a place of common customisation. It main purpose is transleate event to either message or notificationIntent Becuase the payload in event is not know to notiflow, client has to provide custom implementation of such conversion. This is done by implementing InputEvent2MessageConverterExtension interface. For example @Bean public InputEvent2MessageConverterExtension event2Message() { return new InputEvent2MessageConverterExtension () { @Override public Optional<PayloadValidationException> canHandle(GenericEvent payload) { if (payload.getPayloadAsPojo() instanceof TestPayload) { return Optional.empty(); } return Optional.of(new PayloadValidationException(\"No test payload\")); } @Override public List<com.obj.nc.domain.message.Message<?>> convertEvent(GenericEvent event) { EmailMessage email1 = new EmailMessage(); email1.addRecievingEndpoints( EmailEndpoint.builder().email(\"test@objectify.sk\").build() ); email1.getBody().setSubject(\"Subject\"); email1.getBody().setText(\"text\"); List<com.obj.nc.domain.message.Message<?>> msg = Arrays.asList(email1); return msg; } }; } InputEvent2MessageConverterExtension implementation has to be registered as Spring @Bean","title":"Input event extension converting flow "},{"location":"flows/#intent-processing-flow","text":"TODO","title":"Intent processing flow "},{"location":"flows/#message-processing-flow","text":"The responsiblity of this flow is to perform journaling for all messages which are about to be send. This includes persistance of message and information about recipient of the message. route the message to type dependent sender This flow has API that allows to interact with it. Example: @Autowired private MessageProcessingFlow msgFlow; void exampleSendMessage() { EmailMessage msg = ... // when msgFlow.processMessage(msg); }","title":"Message processing flow "},{"location":"flows/#email-processing-flow","text":"The responsiblity of this flow is to if the email is templated , formate it to final email message if email is localised , send email-per-locale or aggregated into one email decorated html emails to track mail opened by recipient send email This flow has API that allows to interact with it. Example: @Autowired private EmailProcessingFlow emailSendingFlow; void exampleSendFormatedEmail() { EmailMessageTemplated<?> email = ... emailSendingFlow.formatAndSend(email); ... } or @Autowired private EmailProcessingFlow emailSendingFlow; void exampleSendEmail() { EmailMessage email = ... EmailMessage emailSent = emailSendingFlow .sendEmail(email) .get(1, TimeUnit.SECONDS); }","title":"Email processing Flow "},{"location":"flows/#sms-processing-flow","text":"The responsiblity of this flow is to format SMS message content (only templated SMS are supported as of now) send SMS message","title":"SMS processing Flow "},{"location":"flows/#mailchimp-processing-flow","text":"The responsiblity of this flow is to send Email message using MailChimp transactional API . Formating of the email is in responsibility of MailChimp","title":"MailChimp processing Flow "},{"location":"flows/#error-handling-flow","text":"In the case of exception in any function participating in a flow , the message that caused the error is recieved by this channel with the information about which step was the last that failed. This flow is reposible for resurection af the failed message and execution of retry For this to work in any situation, transaction boundries for steps in flows have to be carefully defined","title":"Error handling flow"},{"location":"flows/#delivery-info-flows","text":"These flows are responsible for persistance of varios journaling information. They listen on predefined topics and document delivery information for given event , intent and message The infomration is later used in notiflow UI for cstatistics and analytics","title":"Delivery Info flows "},{"location":"flows/#test-mode-flow","text":"This is an internal flow which is used in test mode . Its responsibility is to Wait for certain time for messages which should have been send if test mode was not active Aggregate them into single digest Email message Send aggreagted email to predefined recipient","title":"Test mode flow "},{"location":"functions/","text":"","title":"Functions"},{"location":"license/","text":"License MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"web-ui/","text":"","title":"Web UI"}]}