{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notiflow Notiflow is software framework for reliable delivery of email, push notifications and other types of messages. It is written in Java and it uses various Spring modules especially Spring integration. You can find the full list of features To create your first \"Hello world\" project, check the Getting started section To learn more about the architecture and how it is build, check the architecture and design section Goals The main goal of notiflow is to greatly simplify delivery of information messages to the end user of your application. This is achieved by providing solution for many generic problems of message delivery while taking into account the was diversity of use-cases in which application operate and send messages. The problems which notiflow is solving are allow application to emit events and don't worry about who and what should be communicated to the end-users on those events hide complexity of sending messages via different channels like Email, Push, Sms, Mailchimp, .. allow for scalability from tiny to thousand messages per second ensure reliable delivery with delivery error handling provide comprehensive monitoring and debugging of messages processing provide UI for message delivery statistics, metrics and processing details allow for testing message routing, formatting and delivery end-user spam prevention message aggregation To understand in details how notiflow is solving this problems check the full list of features here Architecture and design Main design characteristics of Notiflow are focusing about achieving two main principles Allow for high level of customization Provide solution which can be used as embedded library standalone application on single machine microservice oriented application operating on computer cluster of any size to achieve high level of thruput To achieve this goals notiflow is implemented as set of independent functions where each function is performing exactly one thing (event conversion, email sending, formatting, aggregation, .. ) notiflow provide default composition of these functions which are called flows . Both functions and flows can be added custom functionality is required. It is also possible to customize existing functions or flows using configuration properties or by providing completely custom implementation. You can use Notiflow as embedded into your existing application create custom microservice for notification processing Functions A function in notiflow is a component which performs single distinct operation. It can be a transformation, getting data from another system, persisting processing information or anything else which is important for message delivery. To see full list of implemented functions and for detail description of each individual function, check the API documentation on functions Flows Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow . The data exchange between function in a flow (or between flows) is performed using exchange of data objects which is implemented based on the scalability and deployment requirements either in-memory RabbitMQ Kafka To understand what is the composition of functions into each individual flow , navigate to the Flows chapter The description of data structures and entities exchanged between functions and flows can be found in Entities chapter Web UI Notiflow ships with monitoring and reporting UI written in ReactJS. It aim is to provide reporting and monitoring dashboards graphical interface for configuration of various aspects of notiflow support for message routing and delivery testing Test mode For complete documentation and screenshots of UI navigate to Web UI chapter Let's start To start using Notiflow in your project, navigate to the Getting started section","title":"Fundamentals"},{"location":"#notiflow","text":"Notiflow is software framework for reliable delivery of email, push notifications and other types of messages. It is written in Java and it uses various Spring modules especially Spring integration. You can find the full list of features To create your first \"Hello world\" project, check the Getting started section To learn more about the architecture and how it is build, check the architecture and design section","title":"Notiflow"},{"location":"#goals","text":"The main goal of notiflow is to greatly simplify delivery of information messages to the end user of your application. This is achieved by providing solution for many generic problems of message delivery while taking into account the was diversity of use-cases in which application operate and send messages. The problems which notiflow is solving are allow application to emit events and don't worry about who and what should be communicated to the end-users on those events hide complexity of sending messages via different channels like Email, Push, Sms, Mailchimp, .. allow for scalability from tiny to thousand messages per second ensure reliable delivery with delivery error handling provide comprehensive monitoring and debugging of messages processing provide UI for message delivery statistics, metrics and processing details allow for testing message routing, formatting and delivery end-user spam prevention message aggregation To understand in details how notiflow is solving this problems check the full list of features here","title":"Goals"},{"location":"#architecture-and-design","text":"Main design characteristics of Notiflow are focusing about achieving two main principles Allow for high level of customization Provide solution which can be used as embedded library standalone application on single machine microservice oriented application operating on computer cluster of any size to achieve high level of thruput To achieve this goals notiflow is implemented as set of independent functions where each function is performing exactly one thing (event conversion, email sending, formatting, aggregation, .. ) notiflow provide default composition of these functions which are called flows . Both functions and flows can be added custom functionality is required. It is also possible to customize existing functions or flows using configuration properties or by providing completely custom implementation. You can use Notiflow as embedded into your existing application create custom microservice for notification processing","title":"Architecture and design "},{"location":"#functions","text":"A function in notiflow is a component which performs single distinct operation. It can be a transformation, getting data from another system, persisting processing information or anything else which is important for message delivery. To see full list of implemented functions and for detail description of each individual function, check the API documentation on functions","title":"Functions "},{"location":"#flows","text":"Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow . The data exchange between function in a flow (or between flows) is performed using exchange of data objects which is implemented based on the scalability and deployment requirements either in-memory RabbitMQ Kafka To understand what is the composition of functions into each individual flow , navigate to the Flows chapter The description of data structures and entities exchanged between functions and flows can be found in Entities chapter","title":"Flows "},{"location":"#web-ui","text":"Notiflow ships with monitoring and reporting UI written in ReactJS. It aim is to provide reporting and monitoring dashboards graphical interface for configuration of various aspects of notiflow support for message routing and delivery testing Test mode For complete documentation and screenshots of UI navigate to Web UI chapter","title":"Web UI "},{"location":"#lets-start","text":"To start using Notiflow in your project, navigate to the Getting started section","title":"Let's start "},{"location":"changelog/","text":"","title":"Changelog"},{"location":"entities/","text":"Entities Input event Notification intent Message Delivery info Processing info Failed payload","title":"Payloads"},{"location":"entities/#entities","text":"","title":"Entities"},{"location":"entities/#input-event","text":"","title":"Input event "},{"location":"entities/#notification-intent","text":"","title":"Notification intent "},{"location":"entities/#message","text":"","title":"Message "},{"location":"entities/#delivery-info","text":"","title":"Delivery info "},{"location":"entities/#processing-info","text":"","title":"Processing info "},{"location":"entities/#failed-payload","text":"","title":"Failed payload "},{"location":"examples/","text":"Examples You can find examples on how to use notiflow for specific use-cases. All of these example can be found in the git repository here . If you are missing some example, let us know. We will add it in the near future. Before you begin Check our gradle dependencies to see external libraries which are used across these examples. Add component scanning to you spring boot application so that the notiflow components are picked up by spring 1 2 3 4 5 6 import com.obj.nc.Get ; @SpringBootApplication @ComponentScan ( basePackageClasses = { Get . class , SendEmailApplication . class }) @IntegrationComponentScan ( basePackageClasses = Get . class ) public class YouSpringBootApplication { Send simple Email This example illustrates the use-case when you simply want to send email with constant body text to single recipient. 1 @Autowired private EmailProcessingFlow emailFlow ; To start interacting with email processing flow inject reference to EmailProcessingFlow interface. Then it is straight forward to send an email. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void sendEmail ( String recipient , String subject , String msgText ) { EmailContent body = EmailContent . builder () . subject ( subject ) . text ( msgText ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( recipient ). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); emailFlow . sendEmail ( msg ); } Notiflow is using Spring Email Sender for interaction with SMTP server. You need to configure it using you application.properties file 1 2 3 4 spring.mail.host=localhost spring.mail.port=3025 spring.mail.username=john_doe spring.mail.password=pwd Send Push notification This example illustrates how to send push notification to one specific device using push processing flow . Notiflow uses Firebase Cloud Messaging for sending Android , iOS , Web and other push notifications. To set up client applications, please refer to included links. To be able to communicate with FCM, you need to add path to your Firebase service account file to your application.properties file. 1 nc.firebase.service-account-file-path = $HOME/.firebase/service-account-key.json Inject PushProcessingFlow bean into your sending service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Service @RequiredArgsConstructor public class SendPushService { // inject push processing flow bean private final PushProcessingFlow pushProcessingFlow ; public PushMessage createMessage ( PushEndpoint endpoint , String subject , String msgText ) { PushMessage message = new PushMessage (); message . setBody ( PushContent . builder () . subject ( subject ) . text ( msgText ) . build () ); message . setReceivingEndpoints ( Collections . singletonList ( endpoint ) ); return message ; } public void send ( PushMessage message ) { pushProcessingFlow . sendPushMessage ( message ); } } Then you can create message and send it to desired endpoint. 1 2 3 4 5 6 7 8 public void sendDirectPush () { PushEndpoint endpoint = PushEndpoint . ofToken ( \"someAndroidDeviceFCMToken\" ); PushMessage message = pushService . createMessage ( endpoint , \"Subject\" , \"Hello World!\" ); pushService . send ( message ); } Send Slack message This example illustrates the use-case when you simply want to send slack message with constant body text to single channel. To start sending messages to public slack channel, first create a bot in slack. For simplicity sake, use example here . Then set application properties as follows: 1 2 nc.slack.apiUrl=https://slack.com/api nc.slack.botToken=xoxb-2660284751633-2647758251043-lettersAndNumbers Bot of token always starts with ' xoxb- '. Be sure. that your token starts with this prefix. Next you need channel code. Usually it is part of url (when you are in channel, it is part of url behind last /). Replace the public-slack-channel-code in following code sample with your channel code. 1 2 3 4 5 6 7 8 9 @Autowired private SlackMessageProcessingFlow processingFlow ; void sendSlackMessage () { SlackMessage message = new SlackMessage (); message . setBody ( SlackMessageContent . builder (). text ( \"Hello World!\" ). build ()); message . setReceivingEndpoints ( Collections . singletonList ( SlackEndpoint . builder (). channel ( \"public-slack-channel-code\" ). build ())); processingFlow . sendMessage ( message ); } Send MS Teams message To start sending messages to teams chat, first create an incoming webhook. Follow official documentation . As a result, you have webhook url. Here is sample how to send message to teams chat: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private TeamsMessageProcessingFlow processingFlow ; @Test void sendShortMessage () { TeamsMessage message = new TeamsMessage (); final String webhook = \"https://webhook.office.com/webhookb2/numbersAndLetters\" ; message . setReceivingEndpoints ( Collections . singletonList ( new TeamsEndpoint ( webhook ))); message . setBody ( new TeamsMessageContent ( \"Hello World!\" )); processingFlow . sendMessage ( message ); } Send SMS message Supported way of sending sms is via GatewayApi sms gateway. First create account at https://gatewayapi.com/. Then fill properties as follows: 1 2 3 nc.sms.gateway-api.sendSmsUrl=https://gatewayapi.com/rest/mtsms nc.sms.gateway-api.token=GatewayApiToken nc.sms.gateway-api.sender=YourCompanyName Replace GatewayApiToken with token from your account and YourCompanyName with suitable sender name. Here is sample how to send sms message: 1 2 3 4 5 6 7 8 9 @Autowired private SmsProcessingFlow processingFlow ; void sendMessage () { SmsMessage message = new SmsMessage (); message . setBody ( SimpleTextContent . builder (). text ( \"Hello World!\" ). build ()); message . setReceivingEndpoints ( Arrays . asList ( SmsEndpoint . builder (). phone ( \"+421950123456\" ). build ())); processingFlow . sendMessage ( message ); } Always send sms with correct phone number prefix. In example is +421 used, which is prefix for slovakia. List of prefixes can be found here . Spam prevention Spam prevention support two ways of configuration: - global - endpoint When applying spam prevention, the endpoint configuration has priority over global config. Both are not required. Both configurations share same configuration object with properties: - maxMessagesUnit (enum) - Allowed values are: MINUTES , HOURS , DAYS . - maxMessagesTimeFrame (int) - how many units are in time frame - maxMessages (int) - maximum of sent messages per time frame Global settings Actual supported global endpoint configurations are: - email - slack - sms - teams - push Every endpoint has same properties. As example email endpoint configuration is provided. 1 2 3 nc.delivery.spam-prevention.email.maxMessages = 5 nc.delivery.spam-prevention.email.maxMessagesTimeFrame = 1 nc.delivery.spam-prevention.email.maxMessagesUnit = DAYS This configuration allows sending of maximum 5 emails per 1 day. Endpoint settings One of ways how to implement spam prevention is via implementing SpamPreventionExtension. In the following example the most important part is method setSpamPreventionSettings when SpamPreventionOption object is created and set to deliveryOptions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Component class EmailSpamPreventionExtension implements SpamPreventionExtension { @Override public BasePayload <?> apply ( BasePayload <?> basePayload ) { for ( ReceivingEndpoint endpoint : basePayload . getReceivingEndpoints ()) { if ( endpoint instanceof EmailEndpoint ) { setSpamPreventionSettings ( endpoint ); } } return basePayload ; } void setSpamPreventionSettings ( ReceivingEndpoint receivingEndpoint ) { DeliveryOptions deliveryOptions = receivingEndpoint . getDeliveryOptions (); if ( deliveryOptions == null ) { deliveryOptions = new DeliveryOptions (); receivingEndpoint . setDeliveryOptions ( deliveryOptions ); } deliveryOptions . setSpamPrevention ( new SpamPreventionOption ( 5 , 1 , SpamPreventionOption . MaxMessageUnit . DAYS )); } } Convert custom application event to Message Covering custom event is very common use-case for notiflow. This separation of responsibility ensures that client application does its job and only emits application events if something important happens. The processing of such events, with regards to notification of users or 3rd parties, is in the responsibility of notiflow. In this example we will send an welcome email to newly registered customer. Let us first define custom event 1 2 3 4 5 6 7 8 9 10 @Data @Builder @NoArgsConstructor @AllArgsConstructor @JsonTypeInfo ( use = Id . CLASS ) public class NewCustomerRegistrationEvent implements IsTypedJson { private String customerName ; private String customerEmail ; } Tha class can be any POJO class which can be serialized to JSON using Jackson library . IsTypedJson Event can be any POJO class. This creates some challenges with JSON serialization and de-serialization. In serialization process, we need to store the FCCN of the POJO into @class attribute of the JSON. This is done using the @JsonTypeInfo ( use = Id . CLASS ) annotation. To deserialize the JSON we need to define common base class IsTypedJson and register theses using Jackson mixins like JsonUtils . getObjectMapper (). addMixIn ( IsTypedJson . class , NewCustomerRegistrationEvent . class ); This process will be simplified in the future versions and the IsTypedJson interface will be removed Next step is to create custom converter which understand the Event class and is able to create notification from it. To achieve this goal we need to provide implementation of InputEvent2MessageConverterExtension interface and register it as @Component 1 2 3 4 5 6 @Component public class EventToMessageConverter implements InputEvent2MessageConverterExtension { ... } The interface define two methods. The method canHandle is used, if our application has more implementations of InputEvent2MessageConverterExtension and we want to decide which one to use for this specific event. If the converted wants to handle the event, it returns Optional . empty () like so 1 2 3 4 5 6 7 8 @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof NewCustomerRegistrationEvent ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"EventToMessageConverter only handles payload of type NewCustomerRegistrationEvent \" )); } Last thing is to implement the conversion itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override public List < Message <?>> convertEvent ( GenericEvent event ) { NewCustomerRegistrationEvent regEvent = event . getPayloadAsPojo (); EmailContent body = EmailContent . builder () . subject ( \"Welcome on board \" + regEvent . getCustomerName ()) . text ( \"We love to have you in the comunity.\" ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( regEvent . getCustomerEmail ()). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); return Arrays . asList ( msg ); } Now we can test the flow using the notiflow REST-API events endpoint which is accepting application events. The test for the specific example could look like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Autowired protected MockMvc mockMvc ; @Test void eventToMessage () throws Exception { NewCustomerRegistrationEvent event = NewCustomerRegistrationEvent . builder () . customerName ( \"John Doe\" ) . customerEmail ( \"john_doe@company.com\" ) . build (); ResultActions resp = mockMvc . perform ( MockMvcRequestBuilders . post ( \"/events\" ) . content ( JsonUtils . writeObjectToJSONString ( event )) . contentType ( APPLICATION_JSON_UTF8 ) . accept ( APPLICATION_JSON_UTF8 )); resp . andExpect ( status (). is2xxSuccessful ()) . andExpect ( jsonPath ( \"$.ncEventId\" ). value ( CoreMatchers . notNullValue ())); boolean recieved = greenMail . waitForIncomingEmail ( 5000L , 1 ); assertEquals ( true , recieved ); assertEquals ( 1 , greenMail . getReceivedMessages (). length ); MimeMessage receivedMessage = greenMail . getReceivedMessages () [ 0 ] ; MimeMessageParser parsedEmail = new MimeMessageParser ( receivedMessage ). parse (); assertEquals ( \"We love to have you in the comunity.\" , parsedEmail . getPlainContent ()); assertEquals ( \"Welcome on board John Doe\" , parsedEmail . getSubject ()); assertEquals ( 1 , receivedMessage . getAllRecipients (). length ); assertEquals ( \"john_doe@company.com\" , receivedMessage . getAllRecipients () [ 0 ] . toString ()); } @RegisterExtension static GreenMailExtension greenMail = new GreenMailExtension ( ServerSetupTest . SMTP ) . withConfiguration ( GreenMailConfiguration . aConfig (). withUser ( \"john_doe\" , \"pwd\" )) . withPerMethodLifecycle ( false ); Templated Email Using Test mode PostgreSQL data source configuration","title":"Guides"},{"location":"examples/#examples","text":"You can find examples on how to use notiflow for specific use-cases. All of these example can be found in the git repository here . If you are missing some example, let us know. We will add it in the near future.","title":"Examples"},{"location":"examples/#before-you-begin","text":"Check our gradle dependencies to see external libraries which are used across these examples. Add component scanning to you spring boot application so that the notiflow components are picked up by spring 1 2 3 4 5 6 import com.obj.nc.Get ; @SpringBootApplication @ComponentScan ( basePackageClasses = { Get . class , SendEmailApplication . class }) @IntegrationComponentScan ( basePackageClasses = Get . class ) public class YouSpringBootApplication {","title":"Before you begin"},{"location":"examples/#send-simple-email","text":"This example illustrates the use-case when you simply want to send email with constant body text to single recipient. 1 @Autowired private EmailProcessingFlow emailFlow ; To start interacting with email processing flow inject reference to EmailProcessingFlow interface. Then it is straight forward to send an email. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void sendEmail ( String recipient , String subject , String msgText ) { EmailContent body = EmailContent . builder () . subject ( subject ) . text ( msgText ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( recipient ). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); emailFlow . sendEmail ( msg ); } Notiflow is using Spring Email Sender for interaction with SMTP server. You need to configure it using you application.properties file 1 2 3 4 spring.mail.host=localhost spring.mail.port=3025 spring.mail.username=john_doe spring.mail.password=pwd","title":"Send simple Email"},{"location":"examples/#send-push-notification","text":"This example illustrates how to send push notification to one specific device using push processing flow . Notiflow uses Firebase Cloud Messaging for sending Android , iOS , Web and other push notifications. To set up client applications, please refer to included links. To be able to communicate with FCM, you need to add path to your Firebase service account file to your application.properties file. 1 nc.firebase.service-account-file-path = $HOME/.firebase/service-account-key.json Inject PushProcessingFlow bean into your sending service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Service @RequiredArgsConstructor public class SendPushService { // inject push processing flow bean private final PushProcessingFlow pushProcessingFlow ; public PushMessage createMessage ( PushEndpoint endpoint , String subject , String msgText ) { PushMessage message = new PushMessage (); message . setBody ( PushContent . builder () . subject ( subject ) . text ( msgText ) . build () ); message . setReceivingEndpoints ( Collections . singletonList ( endpoint ) ); return message ; } public void send ( PushMessage message ) { pushProcessingFlow . sendPushMessage ( message ); } } Then you can create message and send it to desired endpoint. 1 2 3 4 5 6 7 8 public void sendDirectPush () { PushEndpoint endpoint = PushEndpoint . ofToken ( \"someAndroidDeviceFCMToken\" ); PushMessage message = pushService . createMessage ( endpoint , \"Subject\" , \"Hello World!\" ); pushService . send ( message ); }","title":"Send Push notification"},{"location":"examples/#send-slack-message","text":"This example illustrates the use-case when you simply want to send slack message with constant body text to single channel. To start sending messages to public slack channel, first create a bot in slack. For simplicity sake, use example here . Then set application properties as follows: 1 2 nc.slack.apiUrl=https://slack.com/api nc.slack.botToken=xoxb-2660284751633-2647758251043-lettersAndNumbers Bot of token always starts with ' xoxb- '. Be sure. that your token starts with this prefix. Next you need channel code. Usually it is part of url (when you are in channel, it is part of url behind last /). Replace the public-slack-channel-code in following code sample with your channel code. 1 2 3 4 5 6 7 8 9 @Autowired private SlackMessageProcessingFlow processingFlow ; void sendSlackMessage () { SlackMessage message = new SlackMessage (); message . setBody ( SlackMessageContent . builder (). text ( \"Hello World!\" ). build ()); message . setReceivingEndpoints ( Collections . singletonList ( SlackEndpoint . builder (). channel ( \"public-slack-channel-code\" ). build ())); processingFlow . sendMessage ( message ); }","title":"Send Slack message"},{"location":"examples/#send-ms-teams-message","text":"To start sending messages to teams chat, first create an incoming webhook. Follow official documentation . As a result, you have webhook url. Here is sample how to send message to teams chat: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Autowired private TeamsMessageProcessingFlow processingFlow ; @Test void sendShortMessage () { TeamsMessage message = new TeamsMessage (); final String webhook = \"https://webhook.office.com/webhookb2/numbersAndLetters\" ; message . setReceivingEndpoints ( Collections . singletonList ( new TeamsEndpoint ( webhook ))); message . setBody ( new TeamsMessageContent ( \"Hello World!\" )); processingFlow . sendMessage ( message ); }","title":"Send MS Teams message"},{"location":"examples/#send-sms-message","text":"Supported way of sending sms is via GatewayApi sms gateway. First create account at https://gatewayapi.com/. Then fill properties as follows: 1 2 3 nc.sms.gateway-api.sendSmsUrl=https://gatewayapi.com/rest/mtsms nc.sms.gateway-api.token=GatewayApiToken nc.sms.gateway-api.sender=YourCompanyName Replace GatewayApiToken with token from your account and YourCompanyName with suitable sender name. Here is sample how to send sms message: 1 2 3 4 5 6 7 8 9 @Autowired private SmsProcessingFlow processingFlow ; void sendMessage () { SmsMessage message = new SmsMessage (); message . setBody ( SimpleTextContent . builder (). text ( \"Hello World!\" ). build ()); message . setReceivingEndpoints ( Arrays . asList ( SmsEndpoint . builder (). phone ( \"+421950123456\" ). build ())); processingFlow . sendMessage ( message ); } Always send sms with correct phone number prefix. In example is +421 used, which is prefix for slovakia. List of prefixes can be found here .","title":"Send SMS message"},{"location":"examples/#spam-prevention","text":"Spam prevention support two ways of configuration: - global - endpoint When applying spam prevention, the endpoint configuration has priority over global config. Both are not required. Both configurations share same configuration object with properties: - maxMessagesUnit (enum) - Allowed values are: MINUTES , HOURS , DAYS . - maxMessagesTimeFrame (int) - how many units are in time frame - maxMessages (int) - maximum of sent messages per time frame","title":"Spam prevention"},{"location":"examples/#global-settings","text":"Actual supported global endpoint configurations are: - email - slack - sms - teams - push Every endpoint has same properties. As example email endpoint configuration is provided. 1 2 3 nc.delivery.spam-prevention.email.maxMessages = 5 nc.delivery.spam-prevention.email.maxMessagesTimeFrame = 1 nc.delivery.spam-prevention.email.maxMessagesUnit = DAYS This configuration allows sending of maximum 5 emails per 1 day.","title":"Global settings"},{"location":"examples/#endpoint-settings","text":"One of ways how to implement spam prevention is via implementing SpamPreventionExtension. In the following example the most important part is method setSpamPreventionSettings when SpamPreventionOption object is created and set to deliveryOptions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Component class EmailSpamPreventionExtension implements SpamPreventionExtension { @Override public BasePayload <?> apply ( BasePayload <?> basePayload ) { for ( ReceivingEndpoint endpoint : basePayload . getReceivingEndpoints ()) { if ( endpoint instanceof EmailEndpoint ) { setSpamPreventionSettings ( endpoint ); } } return basePayload ; } void setSpamPreventionSettings ( ReceivingEndpoint receivingEndpoint ) { DeliveryOptions deliveryOptions = receivingEndpoint . getDeliveryOptions (); if ( deliveryOptions == null ) { deliveryOptions = new DeliveryOptions (); receivingEndpoint . setDeliveryOptions ( deliveryOptions ); } deliveryOptions . setSpamPrevention ( new SpamPreventionOption ( 5 , 1 , SpamPreventionOption . MaxMessageUnit . DAYS )); } }","title":"Endpoint settings"},{"location":"examples/#convert-custom-application-event-to-message","text":"Covering custom event is very common use-case for notiflow. This separation of responsibility ensures that client application does its job and only emits application events if something important happens. The processing of such events, with regards to notification of users or 3rd parties, is in the responsibility of notiflow. In this example we will send an welcome email to newly registered customer. Let us first define custom event 1 2 3 4 5 6 7 8 9 10 @Data @Builder @NoArgsConstructor @AllArgsConstructor @JsonTypeInfo ( use = Id . CLASS ) public class NewCustomerRegistrationEvent implements IsTypedJson { private String customerName ; private String customerEmail ; } Tha class can be any POJO class which can be serialized to JSON using Jackson library . IsTypedJson Event can be any POJO class. This creates some challenges with JSON serialization and de-serialization. In serialization process, we need to store the FCCN of the POJO into @class attribute of the JSON. This is done using the @JsonTypeInfo ( use = Id . CLASS ) annotation. To deserialize the JSON we need to define common base class IsTypedJson and register theses using Jackson mixins like JsonUtils . getObjectMapper (). addMixIn ( IsTypedJson . class , NewCustomerRegistrationEvent . class ); This process will be simplified in the future versions and the IsTypedJson interface will be removed Next step is to create custom converter which understand the Event class and is able to create notification from it. To achieve this goal we need to provide implementation of InputEvent2MessageConverterExtension interface and register it as @Component 1 2 3 4 5 6 @Component public class EventToMessageConverter implements InputEvent2MessageConverterExtension { ... } The interface define two methods. The method canHandle is used, if our application has more implementations of InputEvent2MessageConverterExtension and we want to decide which one to use for this specific event. If the converted wants to handle the event, it returns Optional . empty () like so 1 2 3 4 5 6 7 8 @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof NewCustomerRegistrationEvent ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"EventToMessageConverter only handles payload of type NewCustomerRegistrationEvent \" )); } Last thing is to implement the conversion itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override public List < Message <?>> convertEvent ( GenericEvent event ) { NewCustomerRegistrationEvent regEvent = event . getPayloadAsPojo (); EmailContent body = EmailContent . builder () . subject ( \"Welcome on board \" + regEvent . getCustomerName ()) . text ( \"We love to have you in the comunity.\" ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( regEvent . getCustomerEmail ()). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); return Arrays . asList ( msg ); } Now we can test the flow using the notiflow REST-API events endpoint which is accepting application events. The test for the specific example could look like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Autowired protected MockMvc mockMvc ; @Test void eventToMessage () throws Exception { NewCustomerRegistrationEvent event = NewCustomerRegistrationEvent . builder () . customerName ( \"John Doe\" ) . customerEmail ( \"john_doe@company.com\" ) . build (); ResultActions resp = mockMvc . perform ( MockMvcRequestBuilders . post ( \"/events\" ) . content ( JsonUtils . writeObjectToJSONString ( event )) . contentType ( APPLICATION_JSON_UTF8 ) . accept ( APPLICATION_JSON_UTF8 )); resp . andExpect ( status (). is2xxSuccessful ()) . andExpect ( jsonPath ( \"$.ncEventId\" ). value ( CoreMatchers . notNullValue ())); boolean recieved = greenMail . waitForIncomingEmail ( 5000L , 1 ); assertEquals ( true , recieved ); assertEquals ( 1 , greenMail . getReceivedMessages (). length ); MimeMessage receivedMessage = greenMail . getReceivedMessages () [ 0 ] ; MimeMessageParser parsedEmail = new MimeMessageParser ( receivedMessage ). parse (); assertEquals ( \"We love to have you in the comunity.\" , parsedEmail . getPlainContent ()); assertEquals ( \"Welcome on board John Doe\" , parsedEmail . getSubject ()); assertEquals ( 1 , receivedMessage . getAllRecipients (). length ); assertEquals ( \"john_doe@company.com\" , receivedMessage . getAllRecipients () [ 0 ] . toString ()); } @RegisterExtension static GreenMailExtension greenMail = new GreenMailExtension ( ServerSetupTest . SMTP ) . withConfiguration ( GreenMailConfiguration . aConfig (). withUser ( \"john_doe\" , \"pwd\" )) . withPerMethodLifecycle ( false );","title":"Convert custom application event to Message"},{"location":"examples/#templated-email","text":"","title":"Templated Email"},{"location":"examples/#using-test-mode","text":"","title":"Using Test mode"},{"location":"examples/#postgresql-data-source-configuration","text":"","title":"PostgreSQL data source configuration "},{"location":"features/","text":"Notiflow features There are many applications that communicate with its users in an asynchronous fashion using various means like emails or mobile push messages. Sending a message seems to be a simple task at first and most application decide for straight forward solution and use Emails to communicate with users. In most cases they simply call SMTP server when condition for notification are met. This approach can quickly result in unexpected and non-trivial development costs as the requirements evolve. Example of such requirements are Email has to be generated from template Notification has to have some delivery guaranties and the engine has to be able to handle error cases What was send? To whom? And when? Notification has to be send using different channel, not only via Email. This can be Push notification on mobil phone, Slack message, SMS, .. and there are many more. Notiflow solve a lot of these generic problems. The list of all its features is described in the next chapiters. Different messaging channels Notiflow let you abstract from channel you want to use to inform your users or customers an takes care about implementation details of these channels. Email Android/iOS push message SMS Facebook post Tweet Slack Microsoft Teams message ... To find out more about how to configure the various channels check the configuration options of specific sender Message templates You can define beautiful dynamic message content using Thymeleaf templates across all of the message channels. To find out more about configuration of templates check our Cook book in the templates section. Test mode Test your configuration before going to production. Notiflow let you turn on the Test mode which ensures that all processing happens like in normal production environment except of the send step. Instead, messages get aggregated and can be inspected using Web UI or will be send in single digest Email. To find out more about turning on the test mode check our Cook book in the Test mode section. Message delivery in predefined hours (future versions) You can configure how and when recipients should receive your message. For example you might want to send SMS in working hours and Email on weekends you can postpone the message delivery if outside of working hours. Message aggregation (future versions) Instead of sending message each time some application event occurs, configure notiflow to send single aggregated message which consists of all messages which would have been send in the given time period Massage delivery tracking Have a detailed view on status of your notification. For most channels we provided information if the messages is currently being Processing in notiflow Sent to recipient Delivered Read Failed You can further inspect when and how the message or event has been processed using the Web UI Fault tolerance Notiflow provides several level of fault tolerance. You can deploy notiflow on you computer cluster and provide fault tolerance of HW infrastructure by duplicating components which are processing messages. The components ( functions ) communicate using some message broker and the deployment provides not only assurance against HW outages but allows for high throughput if required. If message processing fails because of problems in data of network connectivity to 3rd party components, notiflow will put the message to the area for failed messages and allow user to resurrect the message processing from the failed step once the problem has been resolved Recipient spam prevention Do you have customers that you definitively don't want to send more than N messages in a given time period? Configure spam prevention mechanism in notiflow to either reject messages which would pass the limit or send them as single aggregate message at the end of that period. Message prioritization (future versions) Notiflow does its best to process messages as fast as possible but there might be a case when you want the message to be delivered before Notiflow processes all prior messages. For this purpose, you can prioritize your messages so that the more important are always processed before the others. Scheduled notification / PULL based notification If you need to query some other resources to find out if something important happened, so that you can notify those who are interested, you can schedule when the notification flow should start. If you have a data source exposing data aboul contracts expiration, you can configure Notiflow to inform you X days before the expiration happens Web UI for monitoring and statistics (Paid component) Find out more about our Web UI and information it can provide like What event has beed received by the Notiflow What are delivery statistics What messages has been received by specific recipient What messages would have been send if not in Test mode","title":"Features"},{"location":"features/#notiflow-features","text":"There are many applications that communicate with its users in an asynchronous fashion using various means like emails or mobile push messages. Sending a message seems to be a simple task at first and most application decide for straight forward solution and use Emails to communicate with users. In most cases they simply call SMTP server when condition for notification are met. This approach can quickly result in unexpected and non-trivial development costs as the requirements evolve. Example of such requirements are Email has to be generated from template Notification has to have some delivery guaranties and the engine has to be able to handle error cases What was send? To whom? And when? Notification has to be send using different channel, not only via Email. This can be Push notification on mobil phone, Slack message, SMS, .. and there are many more. Notiflow solve a lot of these generic problems. The list of all its features is described in the next chapiters.","title":"Notiflow features"},{"location":"features/#different-messaging-channels","text":"Notiflow let you abstract from channel you want to use to inform your users or customers an takes care about implementation details of these channels. Email Android/iOS push message SMS Facebook post Tweet Slack Microsoft Teams message ... To find out more about how to configure the various channels check the configuration options of specific sender","title":"Different messaging channels"},{"location":"features/#message-templates","text":"You can define beautiful dynamic message content using Thymeleaf templates across all of the message channels. To find out more about configuration of templates check our Cook book in the templates section.","title":"Message templates"},{"location":"features/#test-mode","text":"Test your configuration before going to production. Notiflow let you turn on the Test mode which ensures that all processing happens like in normal production environment except of the send step. Instead, messages get aggregated and can be inspected using Web UI or will be send in single digest Email. To find out more about turning on the test mode check our Cook book in the Test mode section.","title":"Test mode"},{"location":"features/#message-delivery-in-predefined-hours-future-versions","text":"You can configure how and when recipients should receive your message. For example you might want to send SMS in working hours and Email on weekends you can postpone the message delivery if outside of working hours.","title":"Message delivery in predefined hours (future versions)"},{"location":"features/#message-aggregation-future-versions","text":"Instead of sending message each time some application event occurs, configure notiflow to send single aggregated message which consists of all messages which would have been send in the given time period","title":"Message aggregation (future versions)"},{"location":"features/#massage-delivery-tracking","text":"Have a detailed view on status of your notification. For most channels we provided information if the messages is currently being Processing in notiflow Sent to recipient Delivered Read Failed You can further inspect when and how the message or event has been processed using the Web UI","title":"Massage delivery tracking"},{"location":"features/#fault-tolerance","text":"Notiflow provides several level of fault tolerance. You can deploy notiflow on you computer cluster and provide fault tolerance of HW infrastructure by duplicating components which are processing messages. The components ( functions ) communicate using some message broker and the deployment provides not only assurance against HW outages but allows for high throughput if required. If message processing fails because of problems in data of network connectivity to 3rd party components, notiflow will put the message to the area for failed messages and allow user to resurrect the message processing from the failed step once the problem has been resolved","title":"Fault tolerance"},{"location":"features/#recipient-spam-prevention","text":"Do you have customers that you definitively don't want to send more than N messages in a given time period? Configure spam prevention mechanism in notiflow to either reject messages which would pass the limit or send them as single aggregate message at the end of that period.","title":"Recipient spam prevention"},{"location":"features/#message-prioritization-future-versions","text":"Notiflow does its best to process messages as fast as possible but there might be a case when you want the message to be delivered before Notiflow processes all prior messages. For this purpose, you can prioritize your messages so that the more important are always processed before the others.","title":"Message prioritization (future versions)"},{"location":"features/#scheduled-notification-pull-based-notification","text":"If you need to query some other resources to find out if something important happened, so that you can notify those who are interested, you can schedule when the notification flow should start. If you have a data source exposing data aboul contracts expiration, you can configure Notiflow to inform you X days before the expiration happens","title":"Scheduled notification / PULL based notification"},{"location":"features/#web-ui-for-monitoring-and-statistics-paid-component","text":"Find out more about our Web UI and information it can provide like What event has beed received by the Notiflow What are delivery statistics What messages has been received by specific recipient What messages would have been send if not in Test mode","title":"Web UI for monitoring and statistics (Paid component)"},{"location":"flows/","text":"Flows Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow. The data between functions in a flow (or between flows) are exchanges via spring integration channels which can me in-memory or configured to some message broker like RabitMQ or Kafka Notification processing variants Notiflow can operate in both PUSH and PULL mode in terms of data that can produce notification PUSH : Notiflow exposes REST API that can be actively called to send Input event / Notification intent / Message to notiflow and trigger notification processing Example: There is a new order in your online shop and you want to send confirmation to your customer. In that case you web shop send Input event to dedicated REST API and notiflow will handle the notification aspect PULL : Notiflow can be configured to fetch data from data source (Database, REST API,..) and decide if the data meet some criteria that could lead to notification Example: if you have a system with contracts that have expiration date, you can configure notiflow to generate notification one month before expiration. You can find full technical description of this flow in the Notification polling chapter Top-level flows The default configuration of notiflow consists of 4 processing stages EventReceiver : Receive and persist input application Event InputEventExtensionConverting : Event to Intent / Message conversion MessageProcessingFlow : Message persistance, formatting, .. Sending : Sending different types of messages via dedicated channel This is high level and simplified view on default notiflow message processing. If notiflow is configured to consume data from external data sources (PULL mode) there is an additional flow for each data source that is created dynamically based on notiflow configuration. There is a step where the data are converted into one either Input event / Notification intent / Message after which the notification follows standard processing. Notification processing (PUSH) The input to standard-flow (and thus start of input processing) can be done by calling one of tree dedicated API endpoints Input event call to persistGenericEvent API method or call REST API Post to /events endpoint Notification intent call processIntent API method Specific Message call processMessage API method or call REST API Post to /messages endpoint Which one of these three types is selected by the client depends on the particular use-case. Input event : This is used when you want to use notiflow as receiver of any specify application event your application can produce. This can be events like \"New order\" in web shop \"Low inventory\" in warehouse User request for 2-factor authentication ... and any other you might need The intension using this approach is to offload as much of the notification processing from the client application as possible. The application focuses on its core business and emits event about what happen. The payload stored in [Input event] can be completely custom and unknown to notiflow Notification intent : TODO Message : Client application already knows everything about the notification it wants to send, especially who is the recipient what is the message type ( Email / SMS / Push /...) what is the message content but still wants to use features like message delivery guaranties , journaling , spam preventions , statistics and others Input event routing flow Input event routing flow is responsible for Receive an event and return control to the caller as soon as possible Receive an event persist the event return controls to the caller as soon as event persisted in notiflow DB Poll for events which should start processing and route them based on the notiflow configuration for input event routing for further processing This step is only active if client what to use event as a starting point for notification processing Input event extension converting flow This flow is a place of common customization. It main purpose is translate event to either message or notificationIntent Because the payload in event is not know to notiflow, client has to provide custom implementation of such conversion. This is done by implementing InputEvent2MessageConverterExtension interface. For example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Bean public InputEvent2MessageConverterExtension event2Message () { return new InputEvent2MessageConverterExtension () { @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof TestPayload ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"No test payload\" )); } @Override public List < com . obj . nc . domain . message . Message <?>> convertEvent ( GenericEvent event ) { EmailMessage email1 = new EmailMessage (); email1 . addReceivingEndpoints ( EmailEndpoint . builder (). email ( \"test@objectify.sk\" ). build () ); email1 . getBody (). setSubject ( \"Subject\" ); email1 . getBody (). setText ( \"text\" ); List < com . obj . nc . domain . message . Message <?>> msg = Arrays . asList ( email1 ); return msg ; } }; } InputEvent2MessageConverterExtension implementation has to be registered as Spring @Bean Intent processing flow TODO Message processing flow The responsibility of this flow is to perform journaling for all messages which are about to be send. This includes persistance of message and information about recipient of the message. route the message to type dependent sender This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 8 @Autowired private MessageProcessingFlow msgFlow ; void exampleSendMessage () { EmailMessage msg = ... // when msgFlow . processMessage ( msg ); } Email processing flow The responsibility of this flow is to if the email is templated , formate it to final email message if email is localized , send email-per-locale or aggregated into one email decorated html emails to track mail opened by recipient send email This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendFormattedEmail () { EmailMessageTemplated <?> email = ... emailSendingFlow . formatAndSend ( email ); ... } or 1 2 3 4 5 6 7 8 9 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendEmail () { EmailMessage email = ... EmailMessage emailSent = emailSendingFlow . sendEmail ( email ) . get ( 1 , TimeUnit . SECONDS ); } SMS processing flow The responsibility of this flow is to format SMS message content (only templated SMS are supported as of now) send SMS message MailChimp processing flow The responsibility of this flow is to send Email message using MailChimp transactional API . Formatting of the email is in responsibility of MailChimp Push message processing flow The responsibility of this flow is to send Push notification using Firebase Cloud Messaging to target topic or device Error handling flow In the case of exception in any function participating in a flow , the message that caused the error is received by this channel with the information about which step was the last that failed. This flow is responsible for resurrection af the failed message and execution of retry For this to work in any situation, transaction boundaries for steps in flows have to be carefully defined External data-source notification data polling (PULL) You are able to configure data sources that provide notiflow with arbitrary data. You can then configure conditions to check against theses data and if matched notiflow will trigger notification processing based on further configuration. This mode is useful if you have application with for example contracts or orders and you want to be notified one month before contract expires. Delivery Info flows These flows are responsible for persistance of various journaling information. They listen on predefined topics and document delivery information for given event , intent and message The information is later used in notiflow UI for statistics and analytics Test mode flow This is an internal flow which is used in test mode . Its responsibility is to Wait for certain time for messages which should have been send if test mode was not active Aggregate them into single digest Email message Send aggregated email to predefined recipient","title":"Flows"},{"location":"flows/#flows","text":"Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow. The data between functions in a flow (or between flows) are exchanges via spring integration channels which can me in-memory or configured to some message broker like RabitMQ or Kafka","title":"Flows"},{"location":"flows/#notification-processing-variants","text":"Notiflow can operate in both PUSH and PULL mode in terms of data that can produce notification PUSH : Notiflow exposes REST API that can be actively called to send Input event / Notification intent / Message to notiflow and trigger notification processing Example: There is a new order in your online shop and you want to send confirmation to your customer. In that case you web shop send Input event to dedicated REST API and notiflow will handle the notification aspect PULL : Notiflow can be configured to fetch data from data source (Database, REST API,..) and decide if the data meet some criteria that could lead to notification Example: if you have a system with contracts that have expiration date, you can configure notiflow to generate notification one month before expiration. You can find full technical description of this flow in the Notification polling chapter","title":"Notification processing variants"},{"location":"flows/#top-level-flows","text":"The default configuration of notiflow consists of 4 processing stages EventReceiver : Receive and persist input application Event InputEventExtensionConverting : Event to Intent / Message conversion MessageProcessingFlow : Message persistance, formatting, .. Sending : Sending different types of messages via dedicated channel This is high level and simplified view on default notiflow message processing. If notiflow is configured to consume data from external data sources (PULL mode) there is an additional flow for each data source that is created dynamically based on notiflow configuration. There is a step where the data are converted into one either Input event / Notification intent / Message after which the notification follows standard processing.","title":"Top-level flows"},{"location":"flows/#notification-processing-push","text":"The input to standard-flow (and thus start of input processing) can be done by calling one of tree dedicated API endpoints Input event call to persistGenericEvent API method or call REST API Post to /events endpoint Notification intent call processIntent API method Specific Message call processMessage API method or call REST API Post to /messages endpoint Which one of these three types is selected by the client depends on the particular use-case. Input event : This is used when you want to use notiflow as receiver of any specify application event your application can produce. This can be events like \"New order\" in web shop \"Low inventory\" in warehouse User request for 2-factor authentication ... and any other you might need The intension using this approach is to offload as much of the notification processing from the client application as possible. The application focuses on its core business and emits event about what happen. The payload stored in [Input event] can be completely custom and unknown to notiflow Notification intent : TODO Message : Client application already knows everything about the notification it wants to send, especially who is the recipient what is the message type ( Email / SMS / Push /...) what is the message content but still wants to use features like message delivery guaranties , journaling , spam preventions , statistics and others","title":"Notification processing (PUSH)"},{"location":"flows/#input-event-routing-flow","text":"Input event routing flow is responsible for Receive an event and return control to the caller as soon as possible Receive an event persist the event return controls to the caller as soon as event persisted in notiflow DB Poll for events which should start processing and route them based on the notiflow configuration for input event routing for further processing This step is only active if client what to use event as a starting point for notification processing","title":"Input event routing flow "},{"location":"flows/#input-event-extension-converting-flow","text":"This flow is a place of common customization. It main purpose is translate event to either message or notificationIntent Because the payload in event is not know to notiflow, client has to provide custom implementation of such conversion. This is done by implementing InputEvent2MessageConverterExtension interface. For example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Bean public InputEvent2MessageConverterExtension event2Message () { return new InputEvent2MessageConverterExtension () { @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof TestPayload ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"No test payload\" )); } @Override public List < com . obj . nc . domain . message . Message <?>> convertEvent ( GenericEvent event ) { EmailMessage email1 = new EmailMessage (); email1 . addReceivingEndpoints ( EmailEndpoint . builder (). email ( \"test@objectify.sk\" ). build () ); email1 . getBody (). setSubject ( \"Subject\" ); email1 . getBody (). setText ( \"text\" ); List < com . obj . nc . domain . message . Message <?>> msg = Arrays . asList ( email1 ); return msg ; } }; } InputEvent2MessageConverterExtension implementation has to be registered as Spring @Bean","title":"Input event extension converting flow "},{"location":"flows/#intent-processing-flow","text":"TODO","title":"Intent processing flow "},{"location":"flows/#message-processing-flow","text":"The responsibility of this flow is to perform journaling for all messages which are about to be send. This includes persistance of message and information about recipient of the message. route the message to type dependent sender This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 8 @Autowired private MessageProcessingFlow msgFlow ; void exampleSendMessage () { EmailMessage msg = ... // when msgFlow . processMessage ( msg ); }","title":"Message processing flow "},{"location":"flows/#email-processing-flow","text":"The responsibility of this flow is to if the email is templated , formate it to final email message if email is localized , send email-per-locale or aggregated into one email decorated html emails to track mail opened by recipient send email This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendFormattedEmail () { EmailMessageTemplated <?> email = ... emailSendingFlow . formatAndSend ( email ); ... } or 1 2 3 4 5 6 7 8 9 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendEmail () { EmailMessage email = ... EmailMessage emailSent = emailSendingFlow . sendEmail ( email ) . get ( 1 , TimeUnit . SECONDS ); }","title":"Email processing flow "},{"location":"flows/#sms-processing-flow","text":"The responsibility of this flow is to format SMS message content (only templated SMS are supported as of now) send SMS message","title":"SMS processing flow "},{"location":"flows/#mailchimp-processing-flow","text":"The responsibility of this flow is to send Email message using MailChimp transactional API . Formatting of the email is in responsibility of MailChimp","title":"MailChimp processing flow "},{"location":"flows/#push-message-processing-flow","text":"The responsibility of this flow is to send Push notification using Firebase Cloud Messaging to target topic or device","title":"Push message processing flow "},{"location":"flows/#error-handling-flow","text":"In the case of exception in any function participating in a flow , the message that caused the error is received by this channel with the information about which step was the last that failed. This flow is responsible for resurrection af the failed message and execution of retry For this to work in any situation, transaction boundaries for steps in flows have to be carefully defined","title":"Error handling flow"},{"location":"flows/#external-data-source-notification-data-polling-pull","text":"You are able to configure data sources that provide notiflow with arbitrary data. You can then configure conditions to check against theses data and if matched notiflow will trigger notification processing based on further configuration. This mode is useful if you have application with for example contracts or orders and you want to be notified one month before contract expires.","title":"External data-source notification data polling (PULL) "},{"location":"flows/#delivery-info-flows","text":"These flows are responsible for persistance of various journaling information. They listen on predefined topics and document delivery information for given event , intent and message The information is later used in notiflow UI for statistics and analytics","title":"Delivery Info flows "},{"location":"flows/#test-mode-flow","text":"This is an internal flow which is used in test mode . Its responsibility is to Wait for certain time for messages which should have been send if test mode was not active Aggregate them into single digest Email message Send aggregated email to predefined recipient","title":"Test mode flow "},{"location":"functions/","text":"","title":"Functions"},{"location":"getting-started/","text":"Getting started Create spring boot application using Spring Initializr Add following dependency to your build tool Maven 1 2 3 4 5 <dependency> <groupId>objectify</groupId> <artifactId>notif-center</artifactId> <version>1.1.6</version> </dependency> Gradle 1 implementation group: 'objectify', name: 'notif-center', version: '1.1.6' Configure database connection which will be used by notiflow for persistance of processing relevant information application.properties 1 2 3 4 spring.datasource.platform=postgres spring.datasource.url=jdbc:postgresql://localhost:5432/db_name spring.datasource.username=user_name spring.datasource.password=password Database configuration You might need to create a new database if you don't have an existing one. There are other options on how to configure data source . That's it. Check examples to do something useful with Notiflow","title":"Installation"},{"location":"getting-started/#getting-started","text":"Create spring boot application using Spring Initializr Add following dependency to your build tool Maven 1 2 3 4 5 <dependency> <groupId>objectify</groupId> <artifactId>notif-center</artifactId> <version>1.1.6</version> </dependency> Gradle 1 implementation group: 'objectify', name: 'notif-center', version: '1.1.6' Configure database connection which will be used by notiflow for persistance of processing relevant information application.properties 1 2 3 4 spring.datasource.platform=postgres spring.datasource.url=jdbc:postgresql://localhost:5432/db_name spring.datasource.username=user_name spring.datasource.password=password Database configuration You might need to create a new database if you don't have an existing one. There are other options on how to configure data source . That's it. Check examples to do something useful with Notiflow","title":"Getting started"},{"location":"license/","text":"License MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"web-ui/","text":"","title":"Web UI"},{"location":"api/delivery-info_api/","text":"Macro Rendering Error TemplateNotFound : api/generated/delivery-info/GET-delivery-info-events/curl-request.md 1 2 3 4 5 6 7 8 9 10 11 Traceback (most recent call last): File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\mkdocs_macros\\plugin.py\", line 449, in render return md_template.render(**page_variables) File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\jinja2\\environment.py\", line 1291, in render self.environment.handle_exception() File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\jinja2\\environment.py\", line 925, in handle_exception raise rewrite_traceback_stack(source=source) File \"<template>\", line 7, in top-level template code File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\jinja2\\loaders.py\", line 214, in get_source raise TemplateNotFound(template) jinja2.exceptions.TemplateNotFound: api/generated/delivery-info/GET-delivery-info-events/curl-request.md","title":"Delivery-info"},{"location":"api/delivery-info_api/#macro-rendering-error","text":"TemplateNotFound : api/generated/delivery-info/GET-delivery-info-events/curl-request.md 1 2 3 4 5 6 7 8 9 10 11 Traceback (most recent call last): File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\mkdocs_macros\\plugin.py\", line 449, in render return md_template.render(**page_variables) File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\jinja2\\environment.py\", line 1291, in render self.environment.handle_exception() File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\jinja2\\environment.py\", line 925, in handle_exception raise rewrite_traceback_stack(source=source) File \"<template>\", line 7, in top-level template code File \"C:\\Users\\Jan\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\jinja2\\loaders.py\", line 214, in get_source raise TemplateNotFound(template) jinja2.exceptions.TemplateNotFound: api/generated/delivery-info/GET-delivery-info-events/curl-request.md","title":"Macro Rendering Error"},{"location":"api/event_api/","text":"Events GET /events Curl request 1 2 3 $ curl 'http://localhost:8080/events/1e0c2499-e66f-427e-a01f-3fc03f9f1ae4' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' HTTPie request 1 2 3 $ http GET 'http://localhost:8080/events/1e0c2499-e66f-427e-a01f-3fc03f9f1ae4' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8' Path parameters /events/{eventId} Parameter Description eventId Internal Notiflow event ID Request body N/A Response body 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"id\" : \"1e0c2499-e66f-427e-a01f-3fc03f9f1ae4\", \"flowId\" : \"default-flow\", \"payloadType\" : null, \"payloadJson\" : { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }, \"externalId\" : null, \"timeCreated\" : \"2021-12-13T08:49:37.937Z\", \"timeConsumed\" : null } Response fields Path Type Description flowId String Optional: Identification of the main flow payloadType Null Optional: Identification of payload type. Can be used for routing configuration externalId Null Optional: Identification of the event provided by the client. Can be used for search payloadJson Object JSON body of the input event id String Internal notiflow ID assigned to the event timeCreated String Internal notiflow timestamp documenting time of persistance timeConsumed Null Internal notiflow timestamp documenting time of beginning of processing payloadJson.@class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO payloadJson.attribute1 String JSON attribute as an example. Can be anything payloadJson.attribute2 String JSON attribute as an example. Can be anything POST /events Curl request 1 2 3 4 5 6 7 8 $ curl 'http://localhost:8080/events' -i -X POST \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' \\ -d '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' HTTPie request 1 2 3 4 5 6 7 $ echo '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' | http POST 'http://localhost:8080/events' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8' Path parameters N/A Request body 1 2 3 4 5 { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" } Response body 1 2 3 { \"ncEventId\" : \"f82ad375-1f43-4d06-938a-34957ec9ce93\" } Response fields Path Type Description ncEventId String Internal notiflow ID assigned to the event. Can be used for searching","title":"Events"},{"location":"api/event_api/#events","text":"","title":"Events"},{"location":"api/event_api/#get-events","text":"","title":"GET /events"},{"location":"api/event_api/#curl-request","text":"1 2 3 $ curl 'http://localhost:8080/events/1e0c2499-e66f-427e-a01f-3fc03f9f1ae4' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8'","title":"Curl request"},{"location":"api/event_api/#httpie-request","text":"1 2 3 $ http GET 'http://localhost:8080/events/1e0c2499-e66f-427e-a01f-3fc03f9f1ae4' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"HTTPie request"},{"location":"api/event_api/#path-parameters","text":"/events/{eventId} Parameter Description eventId Internal Notiflow event ID","title":"Path parameters"},{"location":"api/event_api/#request-body","text":"N/A","title":"Request body"},{"location":"api/event_api/#response-body","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 { \"id\" : \"1e0c2499-e66f-427e-a01f-3fc03f9f1ae4\", \"flowId\" : \"default-flow\", \"payloadType\" : null, \"payloadJson\" : { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }, \"externalId\" : null, \"timeCreated\" : \"2021-12-13T08:49:37.937Z\", \"timeConsumed\" : null }","title":"Response body"},{"location":"api/event_api/#response-fields","text":"Path Type Description flowId String Optional: Identification of the main flow payloadType Null Optional: Identification of payload type. Can be used for routing configuration externalId Null Optional: Identification of the event provided by the client. Can be used for search payloadJson Object JSON body of the input event id String Internal notiflow ID assigned to the event timeCreated String Internal notiflow timestamp documenting time of persistance timeConsumed Null Internal notiflow timestamp documenting time of beginning of processing payloadJson.@class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO payloadJson.attribute1 String JSON attribute as an example. Can be anything payloadJson.attribute2 String JSON attribute as an example. Can be anything","title":"Response fields"},{"location":"api/event_api/#post-events","text":"","title":"POST /events"},{"location":"api/event_api/#curl-request_1","text":"1 2 3 4 5 6 7 8 $ curl 'http://localhost:8080/events' -i -X POST \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' \\ -d '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }'","title":"Curl request"},{"location":"api/event_api/#httpie-request_1","text":"1 2 3 4 5 6 7 $ echo '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' | http POST 'http://localhost:8080/events' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"HTTPie request"},{"location":"api/event_api/#path-parameters_1","text":"N/A","title":"Path parameters"},{"location":"api/event_api/#request-body_1","text":"1 2 3 4 5 { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }","title":"Request body"},{"location":"api/event_api/#response-body_1","text":"1 2 3 { \"ncEventId\" : \"f82ad375-1f43-4d06-938a-34957ec9ce93\" }","title":"Response body"},{"location":"api/event_api/#response-fields_1","text":"Path Type Description ncEventId String Internal notiflow ID assigned to the event. Can be used for searching","title":"Response fields"},{"location":"api/generated/event/GET-events/curl-request/","text":"1 2 3 $ curl 'http://localhost:8080/events/1e0c2499-e66f-427e-a01f-3fc03f9f1ae4' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8'","title":"Curl request"},{"location":"api/generated/event/GET-events/httpie-request/","text":"1 2 3 $ http GET 'http://localhost:8080/events/1e0c2499-e66f-427e-a01f-3fc03f9f1ae4' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"Httpie request"},{"location":"api/generated/event/GET-events/path-parameters/","text":"/events/{eventId} Parameter Description eventId Internal Notiflow event ID","title":"Path parameters"},{"location":"api/generated/event/GET-events/request-body/","text":"1","title":"Request body"},{"location":"api/generated/event/GET-events/response-body/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 { \"id\" : \"1e0c2499-e66f-427e-a01f-3fc03f9f1ae4\", \"flowId\" : \"default-flow\", \"payloadType\" : null, \"payloadJson\" : { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }, \"externalId\" : null, \"timeCreated\" : \"2021-12-13T08:49:37.937Z\", \"timeConsumed\" : null }","title":"Response body"},{"location":"api/generated/event/GET-events/response-fields/","text":"Path Type Description flowId String Optional: Identification of the main flow payloadType Null Optional: Identification of payload type. Can be used for routing configuration externalId Null Optional: Identification of the event provided by the client. Can be used for search payloadJson Object JSON body of the input event id String Internal notiflow ID assigned to the event timeCreated String Internal notiflow timestamp documenting time of persistance timeConsumed Null Internal notiflow timestamp documenting time of beginning of processing payloadJson.@class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO payloadJson.attribute1 String JSON attribute as an example. Can be anything payloadJson.attribute2 String JSON attribute as an example. Can be anything","title":"Response fields"},{"location":"api/generated/event/POST-events/curl-request/","text":"1 2 3 4 5 6 7 8 $ curl 'http://localhost:8080/events' -i -X POST \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' \\ -d '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }'","title":"Curl request"},{"location":"api/generated/event/POST-events/httpie-request/","text":"1 2 3 4 5 6 7 $ echo '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' | http POST 'http://localhost:8080/events' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"Httpie request"},{"location":"api/generated/event/POST-events/request-body/","text":"1 2 3 4 5 { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }","title":"Request body"},{"location":"api/generated/event/POST-events/request-fields/","text":"Path Type Description @class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO attribute1 String JSON attribute as an example. Can be anything attribute2 String JSON attribute as an example. Can be anything","title":"Request fields"},{"location":"api/generated/event/POST-events/response-body/","text":"1 2 3 { \"ncEventId\" : \"f82ad375-1f43-4d06-938a-34957ec9ce93\" }","title":"Response body"},{"location":"api/generated/event/POST-events/response-fields/","text":"Path Type Description ncEventId String Internal notiflow ID assigned to the event. Can be used for searching","title":"Response fields"}]}