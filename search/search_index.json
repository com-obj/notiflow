{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notiflow Notiflow is software framework for reliable delivery of email, push notifications and other types of messages. It is written in Java and it uses various Spring modules especially Spring integration. You can find the full list of features To create your first \"Hello world\" project, check the Getting started section To learn more about the architecture and how it is build, check the architecture and design section Goals The main goal of notiflow is to greatly simplify delivery of information messages to the end user of your application. This is achieved by providing solution for many generic problems of message delivery while taking into account the was diversity of use-cases in which application operate and send messages. The problems which notiflow is solving are allow application to emit events and don't worry about who and what should be communicated to the end-users on those events hide complexity of sending messages via different channels like Email, Push, Sms, Mailchimp, .. allow for scalability from tiny to thousand messages per second ensure reliable delivery with delivery error handling provide comprehensive monitoring and debugging of messages processing provide UI for message delivery statistics, metrics and processing details allow for testing message routing, formatting and delivery end-user spam prevention message aggregation To understand in details how notiflow is solving this problems check the full list of features here Architecture and design Main design characteristics of Notiflow are focusing about achieving two main principles Allow for high level of customization Provide solution which can be used as embedded library standalone application on single machine microservice oriented application operating on computer cluster of any size to achieve high level of thruput To achieve this goals notiflow is implemented as set of independent functions where each function is performing exactly one thing (event conversion, email sending, formatting, aggregation, .. ) notiflow provide default composition of these functions which are called flows . Both functions and flows can be added custom functionality is required. It is also possible to customize existing functions or flows using configuration properties or by providing completely custom implementation. You can use Notiflow as embedded into your existing application create custom microservice for notification processing Functions A function in notiflow is a component which performs single distinct operation. It can be a transformation, getting data from another system, persisting processing information or anything else which is important for message delivery. To see full list of implemented functions and for detail description of each individual function, check the API documentation on functions Flows Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow . The data exchange between function in a flow (or between flows) is performed using exchange of data objects which is implemented based on the scalability and deployment requirements either in-memory RabbitMQ Kafka To understand what is the composition of functions into each individual flow , navigate to the Flows chapter The description of data structures and entities exchanged between functions and flows can be found in Entities chapter Web UI Notiflow ships with monitoring and reporting UI written in ReactJS. It aim is to provide reporting and monitoring dashboards graphical interface for configuration of various aspects of notiflow support for message routing and delivery testing Test mode For complete documentation and screenshots of UI navigate to Web UI chapter Let's start To start using Notiflow in your project, navigate to the Getting started section","title":"Fundamentals"},{"location":"#notiflow","text":"Notiflow is software framework for reliable delivery of email, push notifications and other types of messages. It is written in Java and it uses various Spring modules especially Spring integration. You can find the full list of features To create your first \"Hello world\" project, check the Getting started section To learn more about the architecture and how it is build, check the architecture and design section","title":"Notiflow"},{"location":"#goals","text":"The main goal of notiflow is to greatly simplify delivery of information messages to the end user of your application. This is achieved by providing solution for many generic problems of message delivery while taking into account the was diversity of use-cases in which application operate and send messages. The problems which notiflow is solving are allow application to emit events and don't worry about who and what should be communicated to the end-users on those events hide complexity of sending messages via different channels like Email, Push, Sms, Mailchimp, .. allow for scalability from tiny to thousand messages per second ensure reliable delivery with delivery error handling provide comprehensive monitoring and debugging of messages processing provide UI for message delivery statistics, metrics and processing details allow for testing message routing, formatting and delivery end-user spam prevention message aggregation To understand in details how notiflow is solving this problems check the full list of features here","title":"Goals"},{"location":"#architecture-and-design","text":"Main design characteristics of Notiflow are focusing about achieving two main principles Allow for high level of customization Provide solution which can be used as embedded library standalone application on single machine microservice oriented application operating on computer cluster of any size to achieve high level of thruput To achieve this goals notiflow is implemented as set of independent functions where each function is performing exactly one thing (event conversion, email sending, formatting, aggregation, .. ) notiflow provide default composition of these functions which are called flows . Both functions and flows can be added custom functionality is required. It is also possible to customize existing functions or flows using configuration properties or by providing completely custom implementation. You can use Notiflow as embedded into your existing application create custom microservice for notification processing","title":"Architecture and design "},{"location":"#functions","text":"A function in notiflow is a component which performs single distinct operation. It can be a transformation, getting data from another system, persisting processing information or anything else which is important for message delivery. To see full list of implemented functions and for detail description of each individual function, check the API documentation on functions","title":"Functions "},{"location":"#flows","text":"Flow is composition of functions (build-in or provided via customization) that performs some complex logic. Flows can be further composed into final processing flow . The data exchange between function in a flow (or between flows) is performed using exchange of data objects which is implemented based on the scalability and deployment requirements either in-memory RabbitMQ Kafka To understand what is the composition of functions into each individual flow , navigate to the Flows chapter The description of data structures and entities exchanged between functions and flows can be found in Entities chapter","title":"Flows "},{"location":"#web-ui","text":"Notiflow ships with monitoring and reporting UI written in ReactJS. It aim is to provide reporting and monitoring dashboards graphical interface for configuration of various aspects of notiflow support for message routing and delivery testing Test mode For complete documentation and screenshots of UI navigate to Web UI chapter","title":"Web UI "},{"location":"#lets-start","text":"To start using Notiflow in your project, navigate to the Getting started section","title":"Let's start "},{"location":"changelog/","text":"","title":"Changelog"},{"location":"entities/","text":"Entities Input event Notification intent Message Delivery info Processing info Failed payload","title":"Payloads"},{"location":"entities/#entities","text":"","title":"Entities"},{"location":"entities/#input-event","text":"","title":"Input event "},{"location":"entities/#notification-intent","text":"","title":"Notification intent "},{"location":"entities/#message","text":"","title":"Message "},{"location":"entities/#delivery-info","text":"","title":"Delivery info "},{"location":"entities/#processing-info","text":"","title":"Processing info "},{"location":"entities/#failed-payload","text":"","title":"Failed payload "},{"location":"examples/","text":"Examples You can find examples on how to use notiflow for specific use-cases. All of these example can be found in the git repository here . If you are missing some example, let us know. We will add it in the near future. Before you begin Check our gradle dependencies to see external libraries which are used across these examples. Add component scanning to you spring boot application so that the notiflow components are picked up by spring 1 2 3 4 5 6 import com.obj.nc.Get ; @SpringBootApplication @ComponentScan ( basePackageClasses = { Get . class , SendEmailApplication . class }) @IntegrationComponentScan ( basePackageClasses = Get . class ) public class YouSpringBootApplication { Send simple Email This example illustrates the use-case when you simply want to send email with constant body text to single recipient. 1 @Autowired private EmailProcessingFlow emailFlow ; To start interacting with email processing flow inject reference to EmailProcessingFlow interface. Then it is straight forward to send an email. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void sendEmail ( String recipient , String subject , String msgText ) { EmailContent body = EmailContent . builder () . subject ( subject ) . text ( msgText ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( recipient ). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); emailFlow . sendEmail ( msg ); } Notiflow is using Spring Email Sender for interaction with SMTP server. You need to configure it using you application.properties file 1 2 3 4 spring.mail.host=localhost spring.mail.port=3025 spring.mail.username=john_doe spring.mail.password=pwd Convert custom application event to Message Covering custom event is very common use-case for notiflow. This separation of responsibility ensures that client application does its job and only emits application events if something important happens. The processing of such events, with regards to notification of users or 3rd parties, is in the responsibility of notiflow. In this example we will send an welcome email to newly registered customer. Let us first define custom event 1 2 3 4 5 6 7 8 9 10 @Data @Builder @NoArgsConstructor @AllArgsConstructor @JsonTypeInfo ( use = Id . CLASS ) public class NewCustomerRegistrationEvent implements IsTypedJson { private String customerName ; private String customerEmail ; } Tha class can be any POJO class which can be serialized to JSON using Jackson library . IsTypedJson Event can be any POJO class. This creates some challenges with JSON serialization and de-serialization. In serialization process, we need to store the FCCN of the POJO into @class attribute of the JSON. This is done using the @JsonTypeInfo ( use = Id . CLASS ) annotation. To deserialize the JSON we need to define common base class IsTypedJson and register theses using Jackson mixins like JsonUtils . getObjectMapper (). addMixIn ( IsTypedJson . class , NewCustomerRegistrationEvent . class ); This process will be simplified in the future versions and the IsTypedJson interface will be removed Next step is to create custom converter which understand the Event class and is able to create notification from it. To achieve this goal we need to provide implementation of InputEvent2MessageConverterExtension interface and register it as @Component 1 2 3 4 5 6 @Component public class EventToMessageConverter implements InputEvent2MessageConverterExtension { ... } The interface define two methods. The method canHandle is used, if our application has more implementations of InputEvent2MessageConverterExtension and we want to decide which one to use for this specific event. If the converted wants to handle the event, it returns Optional . empty () like so 1 2 3 4 5 6 7 8 @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof NewCustomerRegistrationEvent ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"EventToMessageConverter only handles payload of type NewCustomerRegistrationEvent \" )); } Last thing is to implement the conversion itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override public List < Message <?>> convertEvent ( GenericEvent event ) { NewCustomerRegistrationEvent regEvent = event . getPayloadAsPojo (); EmailContent body = EmailContent . builder () . subject ( \"Welcome on board \" + regEvent . getCustomerName ()) . text ( \"We love to have you in the comunity.\" ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( regEvent . getCustomerEmail ()). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); return Arrays . asList ( msg ); } Now we can test the flow using the notiflow REST-API events endpoint which is accepting application events. The test for the specific example could look like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Autowired protected MockMvc mockMvc ; @Test void eventToMessage () throws Exception { NewCustomerRegistrationEvent event = NewCustomerRegistrationEvent . builder () . customerName ( \"John Doe\" ) . customerEmail ( \"john_doe@company.com\" ) . build (); ResultActions resp = mockMvc . perform ( MockMvcRequestBuilders . post ( \"/events\" ) . content ( JsonUtils . writeObjectToJSONString ( event )) . contentType ( APPLICATION_JSON_UTF8 ) . accept ( APPLICATION_JSON_UTF8 )); resp . andExpect ( status (). is2xxSuccessful ()) . andExpect ( jsonPath ( \"$.ncEventId\" ). value ( CoreMatchers . notNullValue ())); boolean recieved = greenMail . waitForIncomingEmail ( 5000L , 1 ); assertEquals ( true , recieved ); assertEquals ( 1 , greenMail . getReceivedMessages (). length ); MimeMessage receivedMessage = greenMail . getReceivedMessages () [ 0 ] ; MimeMessageParser parsedEmail = new MimeMessageParser ( receivedMessage ). parse (); assertEquals ( \"We love to have you in the comunity.\" , parsedEmail . getPlainContent ()); assertEquals ( \"Welcome on board John Doe\" , parsedEmail . getSubject ()); assertEquals ( 1 , receivedMessage . getAllRecipients (). length ); assertEquals ( \"john_doe@company.com\" , receivedMessage . getAllRecipients () [ 0 ] . toString ()); } @RegisterExtension static GreenMailExtension greenMail = new GreenMailExtension ( ServerSetupTest . SMTP ) . withConfiguration ( GreenMailConfiguration . aConfig (). withUser ( \"john_doe\" , \"pwd\" )) . withPerMethodLifecycle ( false ); Templated Email Using Test mode PostgreSQL data source configuration","title":"Guides"},{"location":"examples/#examples","text":"You can find examples on how to use notiflow for specific use-cases. All of these example can be found in the git repository here . If you are missing some example, let us know. We will add it in the near future.","title":"Examples"},{"location":"examples/#before-you-begin","text":"Check our gradle dependencies to see external libraries which are used across these examples. Add component scanning to you spring boot application so that the notiflow components are picked up by spring 1 2 3 4 5 6 import com.obj.nc.Get ; @SpringBootApplication @ComponentScan ( basePackageClasses = { Get . class , SendEmailApplication . class }) @IntegrationComponentScan ( basePackageClasses = Get . class ) public class YouSpringBootApplication {","title":"Before you begin"},{"location":"examples/#send-simple-email","text":"This example illustrates the use-case when you simply want to send email with constant body text to single recipient. 1 @Autowired private EmailProcessingFlow emailFlow ; To start interacting with email processing flow inject reference to EmailProcessingFlow interface. Then it is straight forward to send an email. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void sendEmail ( String recipient , String subject , String msgText ) { EmailContent body = EmailContent . builder () . subject ( subject ) . text ( msgText ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( recipient ). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); emailFlow . sendEmail ( msg ); } Notiflow is using Spring Email Sender for interaction with SMTP server. You need to configure it using you application.properties file 1 2 3 4 spring.mail.host=localhost spring.mail.port=3025 spring.mail.username=john_doe spring.mail.password=pwd","title":"Send simple Email"},{"location":"examples/#convert-custom-application-event-to-message","text":"Covering custom event is very common use-case for notiflow. This separation of responsibility ensures that client application does its job and only emits application events if something important happens. The processing of such events, with regards to notification of users or 3rd parties, is in the responsibility of notiflow. In this example we will send an welcome email to newly registered customer. Let us first define custom event 1 2 3 4 5 6 7 8 9 10 @Data @Builder @NoArgsConstructor @AllArgsConstructor @JsonTypeInfo ( use = Id . CLASS ) public class NewCustomerRegistrationEvent implements IsTypedJson { private String customerName ; private String customerEmail ; } Tha class can be any POJO class which can be serialized to JSON using Jackson library . IsTypedJson Event can be any POJO class. This creates some challenges with JSON serialization and de-serialization. In serialization process, we need to store the FCCN of the POJO into @class attribute of the JSON. This is done using the @JsonTypeInfo ( use = Id . CLASS ) annotation. To deserialize the JSON we need to define common base class IsTypedJson and register theses using Jackson mixins like JsonUtils . getObjectMapper (). addMixIn ( IsTypedJson . class , NewCustomerRegistrationEvent . class ); This process will be simplified in the future versions and the IsTypedJson interface will be removed Next step is to create custom converter which understand the Event class and is able to create notification from it. To achieve this goal we need to provide implementation of InputEvent2MessageConverterExtension interface and register it as @Component 1 2 3 4 5 6 @Component public class EventToMessageConverter implements InputEvent2MessageConverterExtension { ... } The interface define two methods. The method canHandle is used, if our application has more implementations of InputEvent2MessageConverterExtension and we want to decide which one to use for this specific event. If the converted wants to handle the event, it returns Optional . empty () like so 1 2 3 4 5 6 7 8 @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof NewCustomerRegistrationEvent ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"EventToMessageConverter only handles payload of type NewCustomerRegistrationEvent \" )); } Last thing is to implement the conversion itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override public List < Message <?>> convertEvent ( GenericEvent event ) { NewCustomerRegistrationEvent regEvent = event . getPayloadAsPojo (); EmailContent body = EmailContent . builder () . subject ( \"Welcome on board \" + regEvent . getCustomerName ()) . text ( \"We love to have you in the comunity.\" ) . build (); EmailEndpoint emailEndpoint = EmailEndpoint . builder (). email ( regEvent . getCustomerEmail ()). build (); EmailMessage msg = new EmailMessage (); msg . addReceivingEndpoints ( emailEndpoint ); msg . setBody ( body ); return Arrays . asList ( msg ); } Now we can test the flow using the notiflow REST-API events endpoint which is accepting application events. The test for the specific example could look like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Autowired protected MockMvc mockMvc ; @Test void eventToMessage () throws Exception { NewCustomerRegistrationEvent event = NewCustomerRegistrationEvent . builder () . customerName ( \"John Doe\" ) . customerEmail ( \"john_doe@company.com\" ) . build (); ResultActions resp = mockMvc . perform ( MockMvcRequestBuilders . post ( \"/events\" ) . content ( JsonUtils . writeObjectToJSONString ( event )) . contentType ( APPLICATION_JSON_UTF8 ) . accept ( APPLICATION_JSON_UTF8 )); resp . andExpect ( status (). is2xxSuccessful ()) . andExpect ( jsonPath ( \"$.ncEventId\" ). value ( CoreMatchers . notNullValue ())); boolean recieved = greenMail . waitForIncomingEmail ( 5000L , 1 ); assertEquals ( true , recieved ); assertEquals ( 1 , greenMail . getReceivedMessages (). length ); MimeMessage receivedMessage = greenMail . getReceivedMessages () [ 0 ] ; MimeMessageParser parsedEmail = new MimeMessageParser ( receivedMessage ). parse (); assertEquals ( \"We love to have you in the comunity.\" , parsedEmail . getPlainContent ()); assertEquals ( \"Welcome on board John Doe\" , parsedEmail . getSubject ()); assertEquals ( 1 , receivedMessage . getAllRecipients (). length ); assertEquals ( \"john_doe@company.com\" , receivedMessage . getAllRecipients () [ 0 ] . toString ()); } @RegisterExtension static GreenMailExtension greenMail = new GreenMailExtension ( ServerSetupTest . SMTP ) . withConfiguration ( GreenMailConfiguration . aConfig (). withUser ( \"john_doe\" , \"pwd\" )) . withPerMethodLifecycle ( false );","title":"Convert custom application event to Message"},{"location":"examples/#templated-email","text":"","title":"Templated Email"},{"location":"examples/#using-test-mode","text":"","title":"Using Test mode"},{"location":"examples/#postgresql-data-source-configuration","text":"","title":"PostgreSQL data source configuration "},{"location":"features/","text":"Notiflow features There are many applications that communicate with its users in an asynchronous fashion using various means like emails or mobile push messages. Sending a message seems to be a simple task at first and most application decide for straight forward solution and use Emails to communicate with users. In most cases they simply call SMTP server when condition for notification are met. This approach can quickly result in unexpected and non-trivial development costs as the requirements evolve. Example of such requirements are * Email has to be generated from template * Notification has to have some delivery guaranties and the engine has to be able to handle error cases * What was send? To whom? And when? * Notification has to be send using different channel, not only via Email. This can be Push notification on mobil phone, Slack message, SMS, .. * and there are many more. Notiflow solve a lot of these generic problems. The list of all its features is described in the next chapiters. Different messaging channels Notiflow let you abstract from channel you want to use to inform your users or customers an takes care about implementation details of these channels. Email Android/iOS push message SMS Facebook post Tweet Slack Microsoft Teams message ... To find out more about how to configure the various channels check the configuration options of specific sender Message templates You can define beautiful dynamic message content using Thymeleaf templates across all of the message channels. To find out more about configuration of templates check our Cook book in the templates section. Test mode Test your configuration before going to production. Notiflow let you turn on the Test mode which ensures that all processing happens like in normal production environment except of the send step. Instead, messages get aggregated and can be inspected using Web UI or will be send in single digest Email. To find out more about turning on the test mode check our Cook book in the Test mode section. Message delivery in predefined hours You can configure how and when recipients should receive your message. For example you might want to send SMS in working hours and Email on weekends you can postpone the message delivery if outside of working hours. Message aggregation Instead of sending message each time some application event occurs, configure notiflow to send single aggregated message which consists of all messages which would have been send in the given time period Massage delivery tracking Have a detailed view on status of your notification. For most channels we provided information if the messages is currently being Processing in notiflow Sent to recipient Delivered Read Failed You can further inspect when and how the message or event has been processed using the Web UI Fault tolerance Notiflow provides several level of fault tolerance. You can deploy notiflow on you computer cluster and provide fault tolerance of HW infrastructure by duplicating components which are processing messages. The components ( functions ) communicate using some message broker and the deployment provides not only assurance against HW outages but allows for high throughput if required. If message processing fails because of problems in data of network connectivity to 3rd party components, notiflow will put the message to the area for failed messages and allow user to resurrect the message processing from the failed step once the problem has been resolved Recipient spam prevention Do you have customers that you definitively don't want to send more than N messages in a given time period? Configure spam prevention mechanism in notiflow to either reject messages which would pass the limit or send them as single aggregate message at the end of that period. Message prioritization Notiflow does its best to process messages as fast as possible but there might be a case when you want the message to be delivered before Notiflow processes all prior messages. For this purpose, you can prioritize your messages so that the more important are always processed before the others. Scheduled notification If you need to query some other resources to find out if something important happened, so that you can notify those who are interested, you can schedule when the notification flow should start. Web UI for monitoring and statistics Get deep inside into using our Web UI What event has beed received by the Notiflow What are delivery statistics What messages has been received by specific recipient What messages would have been send if not in Test mode","title":"Features"},{"location":"features/#notiflow-features","text":"There are many applications that communicate with its users in an asynchronous fashion using various means like emails or mobile push messages. Sending a message seems to be a simple task at first and most application decide for straight forward solution and use Emails to communicate with users. In most cases they simply call SMTP server when condition for notification are met. This approach can quickly result in unexpected and non-trivial development costs as the requirements evolve. Example of such requirements are * Email has to be generated from template * Notification has to have some delivery guaranties and the engine has to be able to handle error cases * What was send? To whom? And when? * Notification has to be send using different channel, not only via Email. This can be Push notification on mobil phone, Slack message, SMS, .. * and there are many more. Notiflow solve a lot of these generic problems. The list of all its features is described in the next chapiters.","title":"Notiflow features"},{"location":"features/#different-messaging-channels","text":"Notiflow let you abstract from channel you want to use to inform your users or customers an takes care about implementation details of these channels. Email Android/iOS push message SMS Facebook post Tweet Slack Microsoft Teams message ... To find out more about how to configure the various channels check the configuration options of specific sender","title":"Different messaging channels"},{"location":"features/#message-templates","text":"You can define beautiful dynamic message content using Thymeleaf templates across all of the message channels. To find out more about configuration of templates check our Cook book in the templates section.","title":"Message templates"},{"location":"features/#test-mode","text":"Test your configuration before going to production. Notiflow let you turn on the Test mode which ensures that all processing happens like in normal production environment except of the send step. Instead, messages get aggregated and can be inspected using Web UI or will be send in single digest Email. To find out more about turning on the test mode check our Cook book in the Test mode section.","title":"Test mode"},{"location":"features/#message-delivery-in-predefined-hours","text":"You can configure how and when recipients should receive your message. For example you might want to send SMS in working hours and Email on weekends you can postpone the message delivery if outside of working hours.","title":"Message delivery in predefined hours"},{"location":"features/#message-aggregation","text":"Instead of sending message each time some application event occurs, configure notiflow to send single aggregated message which consists of all messages which would have been send in the given time period","title":"Message aggregation"},{"location":"features/#massage-delivery-tracking","text":"Have a detailed view on status of your notification. For most channels we provided information if the messages is currently being Processing in notiflow Sent to recipient Delivered Read Failed You can further inspect when and how the message or event has been processed using the Web UI","title":"Massage delivery tracking"},{"location":"features/#fault-tolerance","text":"Notiflow provides several level of fault tolerance. You can deploy notiflow on you computer cluster and provide fault tolerance of HW infrastructure by duplicating components which are processing messages. The components ( functions ) communicate using some message broker and the deployment provides not only assurance against HW outages but allows for high throughput if required. If message processing fails because of problems in data of network connectivity to 3rd party components, notiflow will put the message to the area for failed messages and allow user to resurrect the message processing from the failed step once the problem has been resolved","title":"Fault tolerance"},{"location":"features/#recipient-spam-prevention","text":"Do you have customers that you definitively don't want to send more than N messages in a given time period? Configure spam prevention mechanism in notiflow to either reject messages which would pass the limit or send them as single aggregate message at the end of that period.","title":"Recipient spam prevention"},{"location":"features/#message-prioritization","text":"Notiflow does its best to process messages as fast as possible but there might be a case when you want the message to be delivered before Notiflow processes all prior messages. For this purpose, you can prioritize your messages so that the more important are always processed before the others.","title":"Message prioritization"},{"location":"features/#scheduled-notification","text":"If you need to query some other resources to find out if something important happened, so that you can notify those who are interested, you can schedule when the notification flow should start.","title":"Scheduled notification"},{"location":"features/#web-ui-for-monitoring-and-statistics","text":"Get deep inside into using our Web UI What event has beed received by the Notiflow What are delivery statistics What messages has been received by specific recipient What messages would have been send if not in Test mode","title":"Web UI for monitoring and statistics"},{"location":"flows/","text":"Flows Flow is composition of functions (build-in or provided via customisation) that performs some complex logic. Flows can be further composed into final processing flow. The data between functions in a flow (or between flows) are exchanges via spring integration channels which can me in-memory or configured to some message broker like RabitMQ or Kafka Top-level flows (standard-flow) The default configuration of notiflow cosists of 4 procesing stages EventReceiver : Recieve and persist input application Event InputEventExtensionConverting : Event to Intent / Message conversion MessageProcessingFlow : Message persistance, formatting, .. Sending : Sending different types of messages via dedicated channel This is high level and simplified view on defualt notiflow message processing. Next section describe individual flows in detail Notification processing variants The input to standard-flow (and thus start of input processing) can be done by calling one tree dedicated API enpoints Input event call to persistGenericEvent API method or call REST API Post to /events endpoint Notification intent call processIntent API method Specific Message call processMessage API method or call REST API Post to /messages endpoint Which one of these three types is selected by the client depends on the particular use-case. Input event : This is used when you want to use notiflow as reciever of any specifi application event your application can produce. This can be events like \"New order\" in web shop \"Low inventory\" in wharehouse User reuquest for 2-factor authentication ... and any other you might need The intension using this aproach is to ofload as much of the notification processing from the client application as possible. The application focuses on its core business and emits event about what happed. The payload stored in [Input event] can be completely custom and uknown to notiflow Notification intent : TODO Message : Client application already knows everything about the notification it wants to send, especially who is the recipient what is the message type ( Email / SMS / Push /...) what is the message content but still wants to use features like message delivery guaranties , journaling , spam preventions , statistics and others Input event routing flow Input event routing flow is responsible for Recieve an event and retun controll to the caller as soon as possible Recieve an event persist the event return controll to the caller as soon as event persisted in notflow DB Poll for events which should start processing and route them based on the notiflow configuration for input event routing for further processing This step is only active if client what to use event as a starting point for notification processing Input event extension converting flow This flow is a place of common customisation. It main purpose is transleate event to either message or notificationIntent Becuase the payload in event is not know to notiflow, client has to provide custom implementation of such conversion. This is done by implementing InputEvent2MessageConverterExtension interface. For example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Bean public InputEvent2MessageConverterExtension event2Message () { return new InputEvent2MessageConverterExtension () { @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof TestPayload ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"No test payload\" )); } @Override public List < com . obj . nc . domain . message . Message <?>> convertEvent ( GenericEvent event ) { EmailMessage email1 = new EmailMessage (); email1 . addReceivingEndpoints ( EmailEndpoint . builder (). email ( \"test@objectify.sk\" ). build () ); email1 . getBody (). setSubject ( \"Subject\" ); email1 . getBody (). setText ( \"text\" ); List < com . obj . nc . domain . message . Message <?>> msg = Arrays . asList ( email1 ); return msg ; } }; } InputEvent2MessageConverterExtension implementation has to be registered as Spring @Bean Intent processing flow TODO Message processing flow The responsiblity of this flow is to perform journaling for all messages which are about to be send. This includes persistance of message and information about recipient of the message. route the message to type dependent sender This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 8 @Autowired private MessageProcessingFlow msgFlow ; void exampleSendMessage () { EmailMessage msg = ... // when msgFlow . processMessage ( msg ); } Email processing Flow The responsiblity of this flow is to if the email is templated , formate it to final email message if email is localised , send email-per-locale or aggregated into one email decorated html emails to track mail opened by recipient send email This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendFormatedEmail () { EmailMessageTemplated <?> email = ... emailSendingFlow . formatAndSend ( email ); ... } or 1 2 3 4 5 6 7 8 9 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendEmail () { EmailMessage email = ... EmailMessage emailSent = emailSendingFlow . sendEmail ( email ) . get ( 1 , TimeUnit . SECONDS ); } SMS processing Flow The responsiblity of this flow is to format SMS message content (only templated SMS are supported as of now) send SMS message MailChimp processing Flow The responsiblity of this flow is to send Email message using MailChimp transactional API . Formating of the email is in responsibility of MailChimp Error handling flow In the case of exception in any function participating in a flow , the message that caused the error is recieved by this channel with the information about which step was the last that failed. This flow is reposible for resurection af the failed message and execution of retry For this to work in any situation, transaction boundries for steps in flows have to be carefully defined Delivery Info flows These flows are responsible for persistance of varios journaling information. They listen on predefined topics and document delivery information for given event , intent and message The infomration is later used in notiflow UI for cstatistics and analytics Test mode flow This is an internal flow which is used in test mode . Its responsibility is to Wait for certain time for messages which should have been send if test mode was not active Aggregate them into single digest Email message Send aggreagted email to predefined recipient","title":"Flows"},{"location":"flows/#flows","text":"Flow is composition of functions (build-in or provided via customisation) that performs some complex logic. Flows can be further composed into final processing flow. The data between functions in a flow (or between flows) are exchanges via spring integration channels which can me in-memory or configured to some message broker like RabitMQ or Kafka","title":"Flows"},{"location":"flows/#top-level-flows-standard-flow","text":"The default configuration of notiflow cosists of 4 procesing stages EventReceiver : Recieve and persist input application Event InputEventExtensionConverting : Event to Intent / Message conversion MessageProcessingFlow : Message persistance, formatting, .. Sending : Sending different types of messages via dedicated channel This is high level and simplified view on defualt notiflow message processing. Next section describe individual flows in detail","title":"Top-level flows (standard-flow)"},{"location":"flows/#notification-processing-variants","text":"The input to standard-flow (and thus start of input processing) can be done by calling one tree dedicated API enpoints Input event call to persistGenericEvent API method or call REST API Post to /events endpoint Notification intent call processIntent API method Specific Message call processMessage API method or call REST API Post to /messages endpoint Which one of these three types is selected by the client depends on the particular use-case. Input event : This is used when you want to use notiflow as reciever of any specifi application event your application can produce. This can be events like \"New order\" in web shop \"Low inventory\" in wharehouse User reuquest for 2-factor authentication ... and any other you might need The intension using this aproach is to ofload as much of the notification processing from the client application as possible. The application focuses on its core business and emits event about what happed. The payload stored in [Input event] can be completely custom and uknown to notiflow Notification intent : TODO Message : Client application already knows everything about the notification it wants to send, especially who is the recipient what is the message type ( Email / SMS / Push /...) what is the message content but still wants to use features like message delivery guaranties , journaling , spam preventions , statistics and others","title":"Notification processing variants"},{"location":"flows/#input-event-routing-flow","text":"Input event routing flow is responsible for Recieve an event and retun controll to the caller as soon as possible Recieve an event persist the event return controll to the caller as soon as event persisted in notflow DB Poll for events which should start processing and route them based on the notiflow configuration for input event routing for further processing This step is only active if client what to use event as a starting point for notification processing","title":"Input event routing flow "},{"location":"flows/#input-event-extension-converting-flow","text":"This flow is a place of common customisation. It main purpose is transleate event to either message or notificationIntent Becuase the payload in event is not know to notiflow, client has to provide custom implementation of such conversion. This is done by implementing InputEvent2MessageConverterExtension interface. For example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Bean public InputEvent2MessageConverterExtension event2Message () { return new InputEvent2MessageConverterExtension () { @Override public Optional < PayloadValidationException > canHandle ( GenericEvent payload ) { if ( payload . getPayloadAsPojo () instanceof TestPayload ) { return Optional . empty (); } return Optional . of ( new PayloadValidationException ( \"No test payload\" )); } @Override public List < com . obj . nc . domain . message . Message <?>> convertEvent ( GenericEvent event ) { EmailMessage email1 = new EmailMessage (); email1 . addReceivingEndpoints ( EmailEndpoint . builder (). email ( \"test@objectify.sk\" ). build () ); email1 . getBody (). setSubject ( \"Subject\" ); email1 . getBody (). setText ( \"text\" ); List < com . obj . nc . domain . message . Message <?>> msg = Arrays . asList ( email1 ); return msg ; } }; } InputEvent2MessageConverterExtension implementation has to be registered as Spring @Bean","title":"Input event extension converting flow "},{"location":"flows/#intent-processing-flow","text":"TODO","title":"Intent processing flow "},{"location":"flows/#message-processing-flow","text":"The responsiblity of this flow is to perform journaling for all messages which are about to be send. This includes persistance of message and information about recipient of the message. route the message to type dependent sender This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 8 @Autowired private MessageProcessingFlow msgFlow ; void exampleSendMessage () { EmailMessage msg = ... // when msgFlow . processMessage ( msg ); }","title":"Message processing flow "},{"location":"flows/#email-processing-flow","text":"The responsiblity of this flow is to if the email is templated , formate it to final email message if email is localised , send email-per-locale or aggregated into one email decorated html emails to track mail opened by recipient send email This flow has API that allows to interact with it. Example: 1 2 3 4 5 6 7 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendFormatedEmail () { EmailMessageTemplated <?> email = ... emailSendingFlow . formatAndSend ( email ); ... } or 1 2 3 4 5 6 7 8 9 @Autowired private EmailProcessingFlow emailSendingFlow ; void exampleSendEmail () { EmailMessage email = ... EmailMessage emailSent = emailSendingFlow . sendEmail ( email ) . get ( 1 , TimeUnit . SECONDS ); }","title":"Email processing Flow "},{"location":"flows/#sms-processing-flow","text":"The responsiblity of this flow is to format SMS message content (only templated SMS are supported as of now) send SMS message","title":"SMS processing Flow "},{"location":"flows/#mailchimp-processing-flow","text":"The responsiblity of this flow is to send Email message using MailChimp transactional API . Formating of the email is in responsibility of MailChimp","title":"MailChimp processing Flow "},{"location":"flows/#error-handling-flow","text":"In the case of exception in any function participating in a flow , the message that caused the error is recieved by this channel with the information about which step was the last that failed. This flow is reposible for resurection af the failed message and execution of retry For this to work in any situation, transaction boundries for steps in flows have to be carefully defined","title":"Error handling flow"},{"location":"flows/#delivery-info-flows","text":"These flows are responsible for persistance of varios journaling information. They listen on predefined topics and document delivery information for given event , intent and message The infomration is later used in notiflow UI for cstatistics and analytics","title":"Delivery Info flows "},{"location":"flows/#test-mode-flow","text":"This is an internal flow which is used in test mode . Its responsibility is to Wait for certain time for messages which should have been send if test mode was not active Aggregate them into single digest Email message Send aggreagted email to predefined recipient","title":"Test mode flow "},{"location":"functions/","text":"","title":"Functions"},{"location":"getting-started/","text":"Getting started Create spring boot application using Spring Initializr Add following dependency to your build tool Maven 1 2 3 4 5 <dependency> <groupId>objectify</groupId> <artifactId>notif-center</artifactId> <version>1.1.6</version> </dependency> Gradle 1 implementation group: 'objectify', name: 'notif-center', version: '1.1.6' Configure database connection which will be used by notiflow for persistance of processing relevant information application.properties 1 2 3 4 spring.datasource.platform=postgres spring.datasource.url=jdbc:postgresql://localhost:5432/db_name spring.datasource.username=user_name spring.datasource.password=password Database configuration You might need to create a new database if you don't have an existing one. There are other options on how to configure data source . That's it. Check examples to do something useful with Notiflow","title":"Installation"},{"location":"getting-started/#getting-started","text":"Create spring boot application using Spring Initializr Add following dependency to your build tool Maven 1 2 3 4 5 <dependency> <groupId>objectify</groupId> <artifactId>notif-center</artifactId> <version>1.1.6</version> </dependency> Gradle 1 implementation group: 'objectify', name: 'notif-center', version: '1.1.6' Configure database connection which will be used by notiflow for persistance of processing relevant information application.properties 1 2 3 4 spring.datasource.platform=postgres spring.datasource.url=jdbc:postgresql://localhost:5432/db_name spring.datasource.username=user_name spring.datasource.password=password Database configuration You might need to create a new database if you don't have an existing one. There are other options on how to configure data source . That's it. Check examples to do something useful with Notiflow","title":"Getting started"},{"location":"license/","text":"License MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"web-ui/","text":"","title":"Web UI"},{"location":"api/delivery-info_api/","text":"Delivery-info GET /delivery-info/events Curl request 1 2 3 $ curl 'http://localhost:8080/delivery-info/events/e066f44f-baeb-4e5d-9d8e-7d0f568e723d' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' HTTPie request 1 2 3 $ http GET 'http://localhost:8080/delivery-info/events/e066f44f-baeb-4e5d-9d8e-7d0f568e723d' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8' Path parameters /delivery-info/events/{eventId} Parameter Description eventId Internal Notiflow event ID Request body N/A Response body 1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \"endpoint\" : { \"@type\" : \"EMAIL\", \"id\" : \"2aa89436-5c63-47d9-8919-1946b0a3a8a5\", \"deliveryOptions\" : null, \"recipient\" : null, \"timeCreated\" : null, \"email\" : \"jancuzy@gmail.com\", \"endpointId\" : \"jancuzy@gmail.com\" }, \"currentStatus\" : \"SENT\", \"statusReachedAt\" : \"2021-09-07T14:25:44.831Z\" } ] Response fields Path Type Description [].currentStatus String Delivery status. One of PROCESSING, SENT, DELIVERED, READ, FAILED [].statusReachedAt String Time stamp when the status was reached hence when the delivery info was created [].endpoint Object Endpoint for which this delivery info was calculated [].endpoint.id String Internal ID [].endpoint.deliveryOptions Null TODO [].endpoint.recipient Null Information about real recipient to whom this endpoint belongs to [].endpoint.endpointId String Non technical ID of this endpoint (Email address, Phone number, .. [].endpoint.timeCreated Null Timestamp of record creation [].endpoint.@type String Type discriminator of the endpoint type. Will be replaced by @class attribute in the future [].endpoint.email String Email address","title":"Delivery infos"},{"location":"api/delivery-info_api/#delivery-info","text":"","title":"Delivery-info"},{"location":"api/delivery-info_api/#get-delivery-infoevents","text":"","title":"GET /delivery-info/events"},{"location":"api/delivery-info_api/#curl-request","text":"1 2 3 $ curl 'http://localhost:8080/delivery-info/events/e066f44f-baeb-4e5d-9d8e-7d0f568e723d' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8'","title":"Curl request"},{"location":"api/delivery-info_api/#httpie-request","text":"1 2 3 $ http GET 'http://localhost:8080/delivery-info/events/e066f44f-baeb-4e5d-9d8e-7d0f568e723d' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"HTTPie request"},{"location":"api/delivery-info_api/#path-parameters","text":"/delivery-info/events/{eventId} Parameter Description eventId Internal Notiflow event ID","title":"Path parameters"},{"location":"api/delivery-info_api/#request-body","text":"N/A","title":"Request body"},{"location":"api/delivery-info_api/#response-body","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \"endpoint\" : { \"@type\" : \"EMAIL\", \"id\" : \"2aa89436-5c63-47d9-8919-1946b0a3a8a5\", \"deliveryOptions\" : null, \"recipient\" : null, \"timeCreated\" : null, \"email\" : \"jancuzy@gmail.com\", \"endpointId\" : \"jancuzy@gmail.com\" }, \"currentStatus\" : \"SENT\", \"statusReachedAt\" : \"2021-09-07T14:25:44.831Z\" } ]","title":"Response body"},{"location":"api/delivery-info_api/#response-fields","text":"Path Type Description [].currentStatus String Delivery status. One of PROCESSING, SENT, DELIVERED, READ, FAILED [].statusReachedAt String Time stamp when the status was reached hence when the delivery info was created [].endpoint Object Endpoint for which this delivery info was calculated [].endpoint.id String Internal ID [].endpoint.deliveryOptions Null TODO [].endpoint.recipient Null Information about real recipient to whom this endpoint belongs to [].endpoint.endpointId String Non technical ID of this endpoint (Email address, Phone number, .. [].endpoint.timeCreated Null Timestamp of record creation [].endpoint.@type String Type discriminator of the endpoint type. Will be replaced by @class attribute in the future [].endpoint.email String Email address","title":"Response fields"},{"location":"api/event_api/","text":"Events GET /events Curl request 1 2 3 $ curl 'http://localhost:8080/events/f1f3d724-b44a-4196-a0d1-b2ebb578a822' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' HTTPie request 1 2 3 $ http GET 'http://localhost:8080/events/f1f3d724-b44a-4196-a0d1-b2ebb578a822' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8' Path parameters /events/{eventId} Parameter Description eventId Internal Notiflow event ID Request body N/A Response body 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"id\" : \"f1f3d724-b44a-4196-a0d1-b2ebb578a822\", \"flowId\" : \"default-flow\", \"payloadType\" : null, \"payloadJson\" : { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }, \"externalId\" : null, \"timeCreated\" : \"2021-09-07T14:25:50.366Z\", \"timeConsumed\" : null } Response fields Path Type Description flowId String Optional: Identification of the main flow payloadType Null Optional: Identification of payload type. Can be used for routing configuration externalId Null Optional: Identification of the event provided by the client. Can be used for search payloadJson Object JSON body of the input event id String Internal notiflow ID assigned to the event timeCreated String Internal notiflow timestamp documenting time of persistance timeConsumed Null Internal notiflow timestamp documenting time of beginning of processing payloadJson.@class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO payloadJson.attribute1 String JSON attribute as an example. Can be anything payloadJson.attribute2 String JSON attribute as an example. Can be anything POST /events Curl request 1 2 3 4 5 6 7 8 $ curl 'http://localhost:8080/events' -i -X POST \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' \\ -d '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' HTTPie request 1 2 3 4 5 6 7 $ echo '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' | http POST 'http://localhost:8080/events' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8' Path parameters N/A Request body 1 2 3 4 5 { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" } Response body 1 2 3 { \"ncEventId\" : \"8f95ebcd-b8b5-4ec7-bd91-af41628b9a7e\" } Response fields Path Type Description ncEventId String Internal notiflow ID assigned to the event. Can be used for searching","title":"Events"},{"location":"api/event_api/#events","text":"","title":"Events"},{"location":"api/event_api/#get-events","text":"","title":"GET /events"},{"location":"api/event_api/#curl-request","text":"1 2 3 $ curl 'http://localhost:8080/events/f1f3d724-b44a-4196-a0d1-b2ebb578a822' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8'","title":"Curl request"},{"location":"api/event_api/#httpie-request","text":"1 2 3 $ http GET 'http://localhost:8080/events/f1f3d724-b44a-4196-a0d1-b2ebb578a822' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"HTTPie request"},{"location":"api/event_api/#path-parameters","text":"/events/{eventId} Parameter Description eventId Internal Notiflow event ID","title":"Path parameters"},{"location":"api/event_api/#request-body","text":"N/A","title":"Request body"},{"location":"api/event_api/#response-body","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 { \"id\" : \"f1f3d724-b44a-4196-a0d1-b2ebb578a822\", \"flowId\" : \"default-flow\", \"payloadType\" : null, \"payloadJson\" : { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }, \"externalId\" : null, \"timeCreated\" : \"2021-09-07T14:25:50.366Z\", \"timeConsumed\" : null }","title":"Response body"},{"location":"api/event_api/#response-fields","text":"Path Type Description flowId String Optional: Identification of the main flow payloadType Null Optional: Identification of payload type. Can be used for routing configuration externalId Null Optional: Identification of the event provided by the client. Can be used for search payloadJson Object JSON body of the input event id String Internal notiflow ID assigned to the event timeCreated String Internal notiflow timestamp documenting time of persistance timeConsumed Null Internal notiflow timestamp documenting time of beginning of processing payloadJson.@class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO payloadJson.attribute1 String JSON attribute as an example. Can be anything payloadJson.attribute2 String JSON attribute as an example. Can be anything","title":"Response fields"},{"location":"api/event_api/#post-events","text":"","title":"POST /events"},{"location":"api/event_api/#curl-request_1","text":"1 2 3 4 5 6 7 8 $ curl 'http://localhost:8080/events' -i -X POST \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' \\ -d '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }'","title":"Curl request"},{"location":"api/event_api/#httpie-request_1","text":"1 2 3 4 5 6 7 $ echo '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' | http POST 'http://localhost:8080/events' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"HTTPie request"},{"location":"api/event_api/#path-parameters_1","text":"N/A","title":"Path parameters"},{"location":"api/event_api/#request-body_1","text":"1 2 3 4 5 { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }","title":"Request body"},{"location":"api/event_api/#response-body_1","text":"1 2 3 { \"ncEventId\" : \"8f95ebcd-b8b5-4ec7-bd91-af41628b9a7e\" }","title":"Response body"},{"location":"api/event_api/#response-fields_1","text":"Path Type Description ncEventId String Internal notiflow ID assigned to the event. Can be used for searching","title":"Response fields"},{"location":"api/generated/delivery-info/GET-delivery-info-events/curl-request/","text":"1 2 3 $ curl 'http://localhost:8080/delivery-info/events/e066f44f-baeb-4e5d-9d8e-7d0f568e723d' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8'","title":"Curl request"},{"location":"api/generated/delivery-info/GET-delivery-info-events/httpie-request/","text":"1 2 3 $ http GET 'http://localhost:8080/delivery-info/events/e066f44f-baeb-4e5d-9d8e-7d0f568e723d' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"Httpie request"},{"location":"api/generated/delivery-info/GET-delivery-info-events/path-parameters/","text":"/delivery-info/events/{eventId} Parameter Description eventId Internal Notiflow event ID","title":"Path parameters"},{"location":"api/generated/delivery-info/GET-delivery-info-events/request-body/","text":"1","title":"Request body"},{"location":"api/generated/delivery-info/GET-delivery-info-events/response-body/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 [ { \"endpoint\" : { \"@type\" : \"EMAIL\", \"id\" : \"2aa89436-5c63-47d9-8919-1946b0a3a8a5\", \"deliveryOptions\" : null, \"recipient\" : null, \"timeCreated\" : null, \"email\" : \"jancuzy@gmail.com\", \"endpointId\" : \"jancuzy@gmail.com\" }, \"currentStatus\" : \"SENT\", \"statusReachedAt\" : \"2021-09-07T14:25:44.831Z\" } ]","title":"Response body"},{"location":"api/generated/delivery-info/GET-delivery-info-events/response-fields/","text":"Path Type Description [].currentStatus String Delivery status. One of PROCESSING, SENT, DELIVERED, READ, FAILED [].statusReachedAt String Time stamp when the status was reached hence when the delivery info was created [].endpoint Object Endpoint for which this delivery info was calculated [].endpoint.id String Internal ID [].endpoint.deliveryOptions Null TODO [].endpoint.recipient Null Information about real recipient to whom this endpoint belongs to [].endpoint.endpointId String Non technical ID of this endpoint (Email address, Phone number, .. [].endpoint.timeCreated Null Timestamp of record creation [].endpoint.@type String Type discriminator of the endpoint type. Will be replaced by @class attribute in the future [].endpoint.email String Email address","title":"Response fields"},{"location":"api/generated/event/GET-events/curl-request/","text":"1 2 3 $ curl 'http://localhost:8080/events/f1f3d724-b44a-4196-a0d1-b2ebb578a822' -i -X GET \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8'","title":"Curl request"},{"location":"api/generated/event/GET-events/httpie-request/","text":"1 2 3 $ http GET 'http://localhost:8080/events/f1f3d724-b44a-4196-a0d1-b2ebb578a822' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"Httpie request"},{"location":"api/generated/event/GET-events/path-parameters/","text":"/events/{eventId} Parameter Description eventId Internal Notiflow event ID","title":"Path parameters"},{"location":"api/generated/event/GET-events/request-body/","text":"1","title":"Request body"},{"location":"api/generated/event/GET-events/response-body/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 { \"id\" : \"f1f3d724-b44a-4196-a0d1-b2ebb578a822\", \"flowId\" : \"default-flow\", \"payloadType\" : null, \"payloadJson\" : { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }, \"externalId\" : null, \"timeCreated\" : \"2021-09-07T14:25:50.366Z\", \"timeConsumed\" : null }","title":"Response body"},{"location":"api/generated/event/GET-events/response-fields/","text":"Path Type Description flowId String Optional: Identification of the main flow payloadType Null Optional: Identification of payload type. Can be used for routing configuration externalId Null Optional: Identification of the event provided by the client. Can be used for search payloadJson Object JSON body of the input event id String Internal notiflow ID assigned to the event timeCreated String Internal notiflow timestamp documenting time of persistance timeConsumed Null Internal notiflow timestamp documenting time of beginning of processing payloadJson.@class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO payloadJson.attribute1 String JSON attribute as an example. Can be anything payloadJson.attribute2 String JSON attribute as an example. Can be anything","title":"Response fields"},{"location":"api/generated/event/POST-events/curl-request/","text":"1 2 3 4 5 6 7 8 $ curl 'http://localhost:8080/events' -i -X POST \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Accept: application/json;charset=UTF-8' \\ -d '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }'","title":"Curl request"},{"location":"api/generated/event/POST-events/httpie-request/","text":"1 2 3 4 5 6 7 $ echo '{ \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }' | http POST 'http://localhost:8080/events' \\ 'Content-Type:application/json;charset=UTF-8' \\ 'Accept:application/json;charset=UTF-8'","title":"Httpie request"},{"location":"api/generated/event/POST-events/request-body/","text":"1 2 3 4 5 { \"@class\" : \"com.obj.nc.controllers.EventsRestControllerTest$TestPayloadForDocs\", \"attribute1\" : \"Your payload value1. Can be anything\", \"attribute2\" : \"Your payload value2. Can be anything\" }","title":"Request body"},{"location":"api/generated/event/POST-events/request-fields/","text":"Path Type Description @class String Payload type information as created by @JsonTypeInfo(use = Id.CLASS). Used for payload de-serialization to POJO attribute1 String JSON attribute as an example. Can be anything attribute2 String JSON attribute as an example. Can be anything","title":"Request fields"},{"location":"api/generated/event/POST-events/response-body/","text":"1 2 3 { \"ncEventId\" : \"8f95ebcd-b8b5-4ec7-bd91-af41628b9a7e\" }","title":"Response body"},{"location":"api/generated/event/POST-events/response-fields/","text":"Path Type Description ncEventId String Internal notiflow ID assigned to the event. Can be used for searching","title":"Response fields"}]}